[[34m  Info  [0m] Starting verification...
[[34m  Info  [0m] Verified: 0 / 0
[[35m Debug  [0m] Generating VCs for functions: insertLaw$0, insertLaw$1, insertLaw$3, insertLaw$2
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 0 / 5
[[35m Debug  [0m]  - Now solving 'precond. (call insertLaw[T](({   assert(thiss.isInst...)' VC for insertLaw @43:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call insertLaw[T](({   assert(thiss.isInst...)' VC for insertLaw @43:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 1 / 5
[[35m Debug  [0m]  - Now solving 'precond. (call insertLaw[T](({   assert(thiss.isInst...)' VC for insertLaw @43:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call insertLaw[T](({   assert(thiss.isInst...)' VC for insertLaw @43:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 2 / 5
[[35m Debug  [0m]  - Now solving 'postcondition' VC for insertLaw @43:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || insertLaw[T](thiss, element) && {
[[35m Debug  [0m]   val res: FunctionalHeap[T] = insert[T](thiss, element)
[[35m Debug  [0m]   size[T](res) == size[T](thiss) + BigInt("1") && set[T](res) == set[T](thiss) ++ Set(element)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for insertLaw @43:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 3 / 5
[[35m Debug  [0m]  - Now solving 'postcondition' VC for insertLaw @43:3...
[[35m Debug  [0m] thiss.isInstanceOf[SplayHeap] || insertLaw[T](thiss, element) && {
[[35m Debug  [0m]   val res: FunctionalHeap[T] = insert[T](thiss, element)
[[35m Debug  [0m]   size[T](res) == size[T](thiss) + BigInt("1") && set[T](res) == set[T](thiss) ++ Set(element)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for insertLaw @43:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 4 / 5
[[35m Debug  [0m]  - Now solving 'law' VC for insertLaw @43:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || {
[[35m Debug  [0m]   val res: FunctionalHeap[T] = insert[T](thiss, element)
[[35m Debug  [0m]   size[T](res) == size[T](thiss) + BigInt("1") && set[T](res) == set[T](thiss) ++ Set(element)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'law' VC for insertLaw @43:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 5 / 5
[[35m Debug  [0m] Generating VCs for functions: rightSubTree$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 5 / 6
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for rightSubTree @33:9...
[[35m Debug  [0m] isTreeEmpty[T](tree) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for rightSubTree @33:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 6 / 6
[[35m Debug  [0m] Generating VCs for functions: min$3, min$5, min$4
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 6 / 12
[[35m Debug  [0m]  - Now solving 'precond. (call min[T](({   assert(thiss.isInstanceOf...)' VC for min @21:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call min[T](({   assert(thiss.isInstanceOf...)' VC for min @21:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 7 / 12
[[35m Debug  [0m]  - Now solving 'precond. (call min[T](({   assert(thiss.isInstanceOf...)' VC for min @21:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call min[T](({   assert(thiss.isInstanceOf...)' VC for min @21:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 8 / 12
[[35m Debug  [0m]  - Now solving 'precond. (call getMinTreeEl[T](scrut, {   assert(thi...)' VC for min @51:27...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.tree.isInstanceOf[Leaf] || isBinarySearchTree[T](thiss.tree, thiss.ord) && !isTreeEmpty[T](thiss.tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call getMinTreeEl[T](scrut, {   assert(thi...)' VC for min @51:27:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 9 / 12
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for min @49:33...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for min @49:33:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 10 / 12
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for min @51:47...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.tree.isInstanceOf[Leaf] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for min @51:47:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 11 / 12
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for min @49:33...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for min @49:33:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 12 / 12
[[35m Debug  [0m] Generating VCs for functions: signumLemma1$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 12 / 15
[[35m Debug  [0m]  - Now solving 'body assertion: Negation overflow' VC for signumLemma1 @17:41...
[[35m Debug  [0m] x < -2147483647 || x > 2147483647 || x != -2147483648
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Negation overflow' VC for signumLemma1 @17:41:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 13 / 15
[[35m Debug  [0m]  - Now solving 'body assertion: Negation overflow' VC for signumLemma1 @17:33...
[[35m Debug  [0m] x < -2147483647 || x > 2147483647 || signum(-x) != -2147483648
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Negation overflow' VC for signumLemma1 @17:33:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 14 / 15
[[35m Debug  [0m]  - Now solving 'postcondition' VC for signumLemma1 @15:3...
[[35m Debug  [0m] x < -2147483647 || x > 2147483647 || signum(x) == -signum(-x)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for signumLemma1 @15:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 15 / 15
[[35m Debug  [0m] Generating VCs for functions: size$1, size$53
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 15 / 16
[[35m Debug  [0m]  - Now solving 'precond. (call size[T](({   assert(thiss.isInstanceO...)' VC for size @29:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call size[T](({   assert(thiss.isInstanceO...)' VC for size @29:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 16 / 16
[[35m Debug  [0m] Generating VCs for functions: partitionGreaterSmaller$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 16 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionGreaterSmaller @427:21...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionGreaterSmaller @427:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 17 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @428:22...
[[35m Debug  [0m] !((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @428:22:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 18 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @429:35...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @429:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 19 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @429:21...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) || !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @429:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 20 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @430:42...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) && compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @430:42:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 21 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @430:29...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) && compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0) || !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @430:29:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 22 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @434:35...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @434:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 23 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @434:21...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @434:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 24 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @435:38...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterSmaller @435:38:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 25 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @435:24...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) || !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterSmaller @435:24:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 26 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterSmaller @444:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   compare[T](ord, t._2, p) < 0 || {
[[35m Debug  [0m]     val nodeValue: T = t._2
[[35m Debug  [0m]     compare[T](ord, nodeValue, p) >= 0 && treeGreaterEqThanValue[T](t._3, nodeValue, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterSmaller @444:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 27 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionGreaterSmaller @501:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)) || !((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](Node[T](t._1, b, t._1), ord)) || compare[T](ord, p, b) < 0 || compare[T](ord, p, b) >= 0 && treeSmallerEqThanValue[T](t._1, b, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionGreaterSmaller @501:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 28 / 41
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterSmaller @525:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)) || !((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](Node[T](t._1, b, t._1), ord)) || !(((compare[T](ord, p, b) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, b, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, b, t._1), p, ord)) || !((((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._3))) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](pr, a, ord)) && isBinarySearchTree[T](Node[T](pr, a, t._3), ord)) || compare[T](ord, a, p) < 0 || compare[T](ord, a, p) >= 0 && treeGreaterEqThanValue[T](t._3, a, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterSmaller @525:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 29 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @434:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @434:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 30 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @442:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val ar: Tree[T] = t._3
[[35m Debug  [0m]   compare[T](ord, t._2, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, t._2, ar, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](ar, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @442:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 31 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @469:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     (((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @469:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 32 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @485:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || (((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @485:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 33 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @496:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)) || (((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](Node[T](t._1, b, t._1), ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @496:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 34 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @507:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)) || !((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](Node[T](t._1, b, t._1), ord)) || ((compare[T](ord, p, b) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, b, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, b, t._1), p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @507:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 35 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @520:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)) || !((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](Node[T](t._1, b, t._1), ord)) || !(((compare[T](ord, p, b) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, b, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, b, t._1), p, ord)) || (((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._3))) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](pr, a, ord)) && isBinarySearchTree[T](Node[T](pr, a, t._3), ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @520:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 36 / 41
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterSmaller @531:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)) || !((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](Node[T](t._1, b, t._1), ord)) || !(((compare[T](ord, p, b) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, b, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, b, t._1), p, ord)) || !((((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._3))) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](pr, a, ord)) && isBinarySearchTree[T](Node[T](pr, a, t._3), ord)) || ((compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]       treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]     }) && treeGreaterEqThanValue[T](pr, p, ord)) && treeGreaterEqThanValue[T](Node[T](pr, a, t._3), p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterSmaller @531:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 37 / 41
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionGreaterSmaller @438:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionGreaterSmaller @438:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 38 / 41
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionGreaterSmaller @439:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || (tree match {
[[35m Debug  [0m]   case Node(al, a, ar) =>
[[35m Debug  [0m]     (al, a, ar)
[[35m Debug  [0m] })._1.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionGreaterSmaller @439:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 39 / 41
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionGreaterSmaller @449:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val ar: Tree[T] = t._3
[[35m Debug  [0m]   val t: Boolean = compare[T](ord, t._2, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, t._2, ar, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](ar, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   true
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionGreaterSmaller @449:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 40 / 41
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partitionGreaterSmaller @531:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) && compare[T](ord, p, treeRootValue[T](leftSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, b, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._3) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, b, t._1)) ++ treeSet[T](Node[T](pr, a, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, b, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (((treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, b, t._1)) + treeSize[T](Node[T](pr, a, t._3)) == treeSize[T](tree)) || !((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](Node[T](t._1, b, t._1), ord)) || !(((compare[T](ord, p, b) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, b, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, b, t._1), p, ord)) || !((((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._3))) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](pr, a, ord)) && isBinarySearchTree[T](Node[T](pr, a, t._3), ord)) || !(((compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]       treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]     }) && treeGreaterEqThanValue[T](pr, p, ord)) && treeGreaterEqThanValue[T](Node[T](pr, a, t._3), p, ord)) || isValidPartition[T](p, tree, ord, (Node[T](t._1, b, t._1), Node[T](pr, a, t._3)))
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partitionGreaterSmaller @531:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 41 / 41
[[35m Debug  [0m] Generating VCs for functions: consistent$0, consistent$1, consistent$4
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 41 / 43
[[35m Debug  [0m]  - Now solving 'precond. (call consistent[T](({   assert(thiss.isIns...)' VC for consistent @33:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call consistent[T](({   assert(thiss.isIns...)' VC for consistent @33:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 42 / 43
[[35m Debug  [0m]  - Now solving 'postcondition' VC for consistent @33:3...
[[35m Debug  [0m] consistent[T](thiss, x, y, z) && (compare[T](thiss, x, y) != 0 || signum(compare[T](thiss, x, z)) == signum(compare[T](thiss, y, z)))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for consistent @33:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 43 / 43
[[35m Debug  [0m] Generating VCs for functions: partitionGreaterEmpty$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 43 / 49
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionGreaterEmpty @408:21...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionGreaterEmpty @408:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 44 / 49
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterEmpty @409:21...
[[35m Debug  [0m] !((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterEmpty @409:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 45 / 49
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterEmpty @415:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || !isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   compare[T](ord, t._2, p) < 0 || {
[[35m Debug  [0m]     val nodeValue: T = t._2
[[35m Debug  [0m]     compare[T](ord, nodeValue, p) >= 0 && treeGreaterEqThanValue[T](t._3, nodeValue, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterEmpty @415:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 46 / 49
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterEmpty @413:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || !isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val ar: Tree[T] = t._3
[[35m Debug  [0m]   compare[T](ord, t._2, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, t._2, ar, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](ar, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterEmpty @413:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 47 / 49
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionGreaterEmpty @411:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || !isTreeEmpty[T](leftSubTree[T](tree)) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionGreaterEmpty @411:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 48 / 49
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partitionGreaterEmpty @412:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || !isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val ar: Tree[T] = t._3
[[35m Debug  [0m]   !(compare[T](ord, t._2, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, t._2, ar, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](ar, p, ord)
[[35m Debug  [0m]   }) || isValidPartition[T](p, tree, ord, (Leaf[T](), tree))
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partitionGreaterEmpty @412:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 49 / 49
[[35m Debug  [0m] Generating VCs for functions: treeSet$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 49 / 53
[[35m Debug  [0m]  - Now solving 'non-negative measure' VC for treeSet @60:3...
[[35m Debug  [0m] TreePrimitiveSize[T](tree) >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'non-negative measure' VC for treeSet @60:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 50 / 53
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for treeSet @62:37...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || TreePrimitiveSize[T](tree.left) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for treeSet @62:37:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 51 / 53
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for treeSet @62:51...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || TreePrimitiveSize[T](tree.right) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for treeSet @62:51:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 52 / 53
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for treeSet @60:43...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for treeSet @60:43:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 53 / 53
[[35m Debug  [0m] Generating VCs for functions: isValidPartition$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 53 / 53
[[35m Debug  [0m] Generating VCs for functions: ordering$0, ordering$2, ordering$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 53 / 56
[[35m Debug  [0m]  - Now solving 'precond. (call ordering[T](({   assert(thiss.isInsta...)' VC for ordering @37:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call ordering[T](({   assert(thiss.isInsta...)' VC for ordering @37:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 54 / 56
[[35m Debug  [0m]  - Now solving 'precond. (call ordering[T](({   assert(thiss.isInsta...)' VC for ordering @37:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call ordering[T](({   assert(thiss.isInsta...)' VC for ordering @37:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 55 / 56
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for ordering @57:40...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for ordering @57:40:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 56 / 56
[[35m Debug  [0m] Generating VCs for functions: isEmpty$3, isEmpty$7, isEmpty$4
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 56 / 59
[[35m Debug  [0m]  - Now solving 'precond. (call isEmpty[T](({   assert(thiss.isInstan...)' VC for isEmpty @25:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call isEmpty[T](({   assert(thiss.isInstan...)' VC for isEmpty @25:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 57 / 59
[[35m Debug  [0m]  - Now solving 'precond. (call isEmpty[T](({   assert(thiss.isInstan...)' VC for isEmpty @25:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call isEmpty[T](({   assert(thiss.isInstan...)' VC for isEmpty @25:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 58 / 59
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for isEmpty @54:47...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for isEmpty @54:47:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 59 / 59
[[35m Debug  [0m] Generating VCs for functions: strictSamllerToNonStrictLemma$0, strictSamllerToNonStrictLemma$1, strictSamllerToNonStrictLemma$2
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 59 / 63
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictSamllerToNonStrictLemma @87:3...
[[35m Debug  [0m] compare[T](thiss, x, y) >= 0 || compare[T](thiss, x, y) <= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictSamllerToNonStrictLemma @87:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 60 / 63
[[35m Debug  [0m]  - Now solving 'precond. (call strictSamllerToNonStrictLemma[T](({  ...)' VC for strictSamllerToNonStrictLemma @87:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictSamllerToNonStrictLemma[T](({  ...)' VC for strictSamllerToNonStrictLemma @87:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 61 / 63
[[35m Debug  [0m]  - Now solving 'precond. (call strictSamllerToNonStrictLemma[T](({  ... (require 2)' VC for strictSamllerToNonStrictLemma @87:3...
[[35m Debug  [0m] compare[T](thiss, x, y) >= 0 || compare[T](thiss, x, y) < 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictSamllerToNonStrictLemma[T](({  ... (require 2)' VC for strictSamllerToNonStrictLemma @87:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 62 / 63
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictSamllerToNonStrictLemma @87:3...
[[35m Debug  [0m] compare[T](thiss, x, y) >= 0 || {
[[35m Debug  [0m]   val x$7: Unit = strictSamllerToNonStrictLemma[T](thiss, x, y)
[[35m Debug  [0m]   compare[T](thiss, x, y) <= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictSamllerToNonStrictLemma @87:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 63 / 63
[[35m Debug  [0m] Generating VCs for functions: set$5, set$76
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 63 / 64
[[35m Debug  [0m]  - Now solving 'precond. (call set[T](({   assert(thiss.isInstanceOf...)' VC for set @33:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call set[T](({   assert(thiss.isInstanceOf...)' VC for set @33:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 64 / 64[[34m  Info  [0m] Verified: 64 / 64
[[35m Debug  [0m] Generating VCs for functions: createFromList$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 64 / 70
[[35m Debug  [0m]  - Now solving 'body assertion' VC for createFromList @25:18...
[[35m Debug  [0m] l.isInstanceOf[Nil] || insertLaw[T](createFromList[T](l.t, ord), l.h)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for createFromList @25:18:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 65 / 70
[[35m Debug  [0m]  - Now solving 'non-negative measure' VC for createFromList @19:3...
[[35m Debug  [0m] ListPrimitiveSize[T](l) >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'non-negative measure' VC for createFromList @19:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 66 / 70
[[35m Debug  [0m]  - Now solving 'postcondition' VC for createFromList @22:23...
[[35m Debug  [0m] !l.isInstanceOf[Nil] || {
[[35m Debug  [0m]   val res: FunctionalHeap[T] = createEmpty[T](ord)
[[35m Debug  [0m]   size[T](res) == size[T](l) && content[T](l) == set[T](res)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for createFromList @22:23:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 67 / 70
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for createFromList @24:25...
[[35m Debug  [0m] l.isInstanceOf[Nil] || ListPrimitiveSize[T](l.t) < ListPrimitiveSize[T](l)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for createFromList @24:25:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 68 / 70
[[35m Debug  [0m]  - Now solving 'postcondition' VC for createFromList @25:11...
[[35m Debug  [0m] l.isInstanceOf[Nil] || {
[[35m Debug  [0m]   val subHeap: FunctionalHeap[T] = createFromList[T](l.t, ord)
[[35m Debug  [0m]   !insertLaw[T](subHeap, l.h) || {
[[35m Debug  [0m]     val res: FunctionalHeap[T] = insert[T](subHeap, l.h)
[[35m Debug  [0m]     size[T](res) == size[T](l) && content[T](l) == set[T](res)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for createFromList @25:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 69 / 70
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for createFromList @21:7...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for createFromList @21:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 70 / 70
[[35m Debug  [0m] Generating VCs for functions: transitive$0, transitive$4, transitive$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 70 / 72
[[35m Debug  [0m]  - Now solving 'precond. (call transitive[T](({   assert(thiss.isIns...)' VC for transitive @29:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call transitive[T](({   assert(thiss.isIns...)' VC for transitive @29:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 71 / 72
[[35m Debug  [0m]  - Now solving 'postcondition' VC for transitive @29:3...
[[35m Debug  [0m] transitive[T](thiss, x, y, z) && (compare[T](thiss, x, y) <= 0 || compare[T](thiss, y, z) <= 0 || compare[T](thiss, x, z) > 0)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for transitive @29:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 72 / 72
[[35m Debug  [0m] Generating VCs for functions: isEmpty$3, isEmpty$7
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 72 / 73
[[35m Debug  [0m]  - Now solving 'precond. (call isEmpty[T](({   assert(thiss.isInstan...)' VC for isEmpty @25:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call isEmpty[T](({   assert(thiss.isInstan...)' VC for isEmpty @25:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 73 / 73
[[35m Debug  [0m] Generating VCs for functions: insert$0, insert$17, insert$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 73 / 80
[[35m Debug  [0m]  - Now solving 'precond. (call insert[T](({   assert(thiss.isInstanc...)' VC for insert @10:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call insert[T](({   assert(thiss.isInstanc...)' VC for insert @10:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 74 / 80
[[35m Debug  [0m]  - Now solving 'precond. (call insert[T](({   assert(thiss.isInstanc...)' VC for insert @10:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call insert[T](({   assert(thiss.isInstanc...)' VC for insert @10:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 75 / 80
[[35m Debug  [0m]  - Now solving 'precond. (call binarySearchTreeSplayInsertion[T]({  ...)' VC for insert @41:15...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || isBinarySearchTree[T](thiss.tree, thiss.ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call binarySearchTreeSplayInsertion[T]({  ...)' VC for insert @41:15:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 76 / 80
[[35m Debug  [0m]  - Now solving 'class invariant' VC for insert @41:5...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || inv[T](SplayHeap[T](binarySearchTreeSplayInsertion[T](thiss.tree, element, thiss.ord), thiss.ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'class invariant' VC for insert @41:5:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 77 / 80
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for insert @41:46...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for insert @41:46:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 78 / 80
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for insert @41:61...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for insert @41:61:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 79 / 80
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for insert @41:67...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || {
[[35m Debug  [0m]   val tree: Tree[T] = binarySearchTreeSplayInsertion[T](thiss.tree, element, thiss.ord)
[[35m Debug  [0m]   thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for insert @41:67:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 80 / 80
[[35m Debug  [0m] Generating VCs for functions: inverse$0, inverse$1, inverse$33
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 80 / 83
[[35m Debug  [0m]  - Now solving 'body assertion: Negation overflow' VC for inverse @26:30...
[[35m Debug  [0m] signum(compare[T](thiss, y, x)) != -2147483648
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Negation overflow' VC for inverse @26:30:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 81 / 83
[[35m Debug  [0m]  - Now solving 'precond. (call inverse[T](({   assert(thiss.isInstan...)' VC for inverse @25:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call inverse[T](({   assert(thiss.isInstan...)' VC for inverse @25:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 82 / 83
[[35m Debug  [0m]  - Now solving 'postcondition' VC for inverse @25:3...
[[35m Debug  [0m] inverse[T](thiss, x, y) && signum(compare[T](thiss, x, y)) == -signum(compare[T](thiss, y, x))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for inverse @25:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 83 / 83
[[35m Debug  [0m] Generating VCs for functions: size$1, size$53, size$2
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 83 / 86
[[35m Debug  [0m]  - Now solving 'precond. (call size[T](({   assert(thiss.isInstanceO...)' VC for size @29:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call size[T](({   assert(thiss.isInstanceO...)' VC for size @29:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 84 / 86
[[35m Debug  [0m]  - Now solving 'precond. (call size[T](({   assert(thiss.isInstanceO...)' VC for size @29:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call size[T](({   assert(thiss.isInstanceO...)' VC for size @29:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 85 / 86
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for size @55:40...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for size @55:40:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 86 / 86
[[35m Debug  [0m] Generating VCs for functions: getMinTreeElTrivialCase$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 86 / 90
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for getMinTreeElTrivialCase @712:21...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for getMinTreeElTrivialCase @712:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 87 / 90
[[35m Debug  [0m]  - Now solving 'body assertion' VC for getMinTreeElTrivialCase @717:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || !isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   (∀el: T. !treeSet[T](t._1).contains(el) && setForall[T](treeSet[T](t._1), (el: T) => compare[T](ord, el, v) >= 0)) && {
[[35m Debug  [0m]     val tmp: Unit = selfEqualityLemma[T](ord, v)
[[35m Debug  [0m]     compare[T](ord, v, v) >= 0
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for getMinTreeElTrivialCase @717:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 88 / 90
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for getMinTreeElTrivialCase @715:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || !isTreeEmpty[T](leftSubTree[T](tree)) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for getMinTreeElTrivialCase @715:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 89 / 90
[[35m Debug  [0m]  - Now solving 'postcondition' VC for getMinTreeElTrivialCase @726:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || !isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   !((∀el: T. !treeSet[T](t._1).contains(el) && setForall[T](treeSet[T](t._1), (el: T) => compare[T](ord, el, v) >= 0)) && {
[[35m Debug  [0m]     val tmp: Unit = selfEqualityLemma[T](ord, v)
[[35m Debug  [0m]     compare[T](ord, v, v) >= 0
[[35m Debug  [0m]   }) || ((isMinTreeEl[T](tree, ord, v) && treeSize[T](t._3) + BigInt("1") == treeSize[T](tree)) && isBinarySearchTree[T](t._3, ord)) && Set(v) ++ treeSet[T](t._3) == treeSet[T](tree)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for getMinTreeElTrivialCase @726:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 90 / 90
[[35m Debug  [0m] Generating VCs for functions: partitionEmpty$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 90 / 91
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partitionEmpty @146:3...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || !isTreeEmpty[T](tree) || isValidPartition[T](p, tree, ord, (Leaf[T](), Leaf[T]()))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partitionEmpty @146:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 91 / 91
[[35m Debug  [0m] Generating VCs for functions: isMinSetEl$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 91 / 91
[[35m Debug  [0m] Generating VCs for functions: monotonicInverseLemmaGreater$0, monotonicInverseLemmaGreater$2, monotonicInverseLemmaGreater$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 91 / 96
[[35m Debug  [0m]  - Now solving 'body assertion' VC for monotonicInverseLemmaGreater @66:12...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || inverse[T](thiss, x, y)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for monotonicInverseLemmaGreater @66:12:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 92 / 96
[[35m Debug  [0m]  - Now solving 'postcondition' VC for monotonicInverseLemmaGreater @64:3...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || !inverse[T](thiss, x, y) || compare[T](thiss, y, x) <= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for monotonicInverseLemmaGreater @64:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 93 / 96
[[35m Debug  [0m]  - Now solving 'precond. (call monotonicInverseLemmaGreater[T](({   ...)' VC for monotonicInverseLemmaGreater @64:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call monotonicInverseLemmaGreater[T](({   ...)' VC for monotonicInverseLemmaGreater @64:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 94 / 96
[[35m Debug  [0m]  - Now solving 'precond. (call monotonicInverseLemmaGreater[T](({   ... (require 2)' VC for monotonicInverseLemmaGreater @64:3...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, x, y) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call monotonicInverseLemmaGreater[T](({   ... (require 2)' VC for monotonicInverseLemmaGreater @64:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 95 / 96
[[35m Debug  [0m]  - Now solving 'postcondition' VC for monotonicInverseLemmaGreater @64:3...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || {
[[35m Debug  [0m]   val x$4: Unit = monotonicInverseLemmaGreater[T](thiss, x, y)
[[35m Debug  [0m]   compare[T](thiss, y, x) <= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for monotonicInverseLemmaGreater @64:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 96 / 96
[[35m Debug  [0m] Generating VCs for functions: signum$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 96 / 96
[[35m Debug  [0m] Generating VCs for functions: partition$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 96 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partitionEmpty[T](p, tree, ord))' VC for partition @671:24...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || !tree.isInstanceOf[Leaf] || isBinarySearchTree[T](tree, ord) && isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partitionEmpty[T](p, tree, ord))' VC for partition @671:24:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 97 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partitionSmallerEmpty[T](p, tree, ord))' VC for partition @673:26...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || !tree.right.isInstanceOf[Leaf] || ((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partitionSmallerEmpty[T](p, tree, ord))' VC for partition @673:26:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 98 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partition[T](p, (scrut.right): @DropV...)' VC for partition @675:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) > 0 || isBinarySearchTree[T](tree.right.right, ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partition[T](p, (scrut.right): @DropV...)' VC for partition @675:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 99 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partitionSmallerSmaller[T](p, tree, s...)' VC for partition @676:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) > 0 || {
[[35m Debug  [0m]   val subParts: (Tree[T], Tree[T]) = partition[T](p, tree.right.right, ord)
[[35m Debug  [0m]   ((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) && compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0) && isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partitionSmallerSmaller[T](p, tree, s...)' VC for partition @676:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 100 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partition[T](p, (scrut.left): @DropVC...)' VC for partition @679:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) <= 0 || isBinarySearchTree[T](tree.right.left, ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partition[T](p, (scrut.left): @DropVC...)' VC for partition @679:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 101 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partitionSmallerGreater[T](p, tree, s...)' VC for partition @680:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) <= 0 || {
[[35m Debug  [0m]   val subParts: (Tree[T], Tree[T]) = partition[T](p, tree.right.left, ord)
[[35m Debug  [0m]   ((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) && compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0) && isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partitionSmallerGreater[T](p, tree, s...)' VC for partition @680:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 102 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partitionGreaterEmpty[T](p, tree, ord))' VC for partition @684:26...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || !tree.left.isInstanceOf[Leaf] || ((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partitionGreaterEmpty[T](p, tree, ord))' VC for partition @684:26:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 103 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partition[T](p, (scrut.right): @DropV...)' VC for partition @686:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) > 0 || isBinarySearchTree[T](tree.left.right, ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partition[T](p, (scrut.right): @DropV...)' VC for partition @686:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 104 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partitionGreaterSmaller[T](p, tree, s...)' VC for partition @687:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) > 0 || {
[[35m Debug  [0m]   val subParts: (Tree[T], Tree[T]) = partition[T](p, tree.left.right, ord)
[[35m Debug  [0m]   ((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) && compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0) && isValidPartition[T](p, rightSubTree[T](leftSubTree[T](tree)), ord, subParts)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partitionGreaterSmaller[T](p, tree, s...)' VC for partition @687:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 105 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partition[T](p, (scrut.left): @DropVC...)' VC for partition @690:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) <= 0 || isBinarySearchTree[T](tree.left.left, ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partition[T](p, (scrut.left): @DropVC...)' VC for partition @690:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 106 / 120
[[35m Debug  [0m]  - Now solving 'precond. (call partitionGreaterGreater[T](p, tree, s...)' VC for partition @691:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) <= 0 || {
[[35m Debug  [0m]   val subParts: (Tree[T], Tree[T]) = partition[T](p, tree.left.left, ord)
[[35m Debug  [0m]   ((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) && compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0) && isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partitionGreaterGreater[T](p, tree, s...)' VC for partition @691:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 107 / 120
[[35m Debug  [0m]  - Now solving 'non-negative measure' VC for partition @695:38...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || TreePrimitiveSize[T](tree) >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'non-negative measure' VC for partition @695:38:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 108 / 120
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partition @671:24...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || !tree.isInstanceOf[Leaf] || isValidPartition[T](p, tree, ord, partitionEmpty[T](p, tree, ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partition @671:24:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 109 / 120
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partition @673:26...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || !tree.right.isInstanceOf[Leaf] || isValidPartition[T](p, tree, ord, partitionSmallerEmpty[T](p, tree, ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partition @673:26:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 110 / 120
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for partition @675:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) > 0 || TreePrimitiveSize[T](tree.right.right) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for partition @675:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 111 / 120
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partition @676:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) > 0 || isValidPartition[T](p, tree, ord, partitionSmallerSmaller[T](p, tree, partition[T](p, tree.right.right, ord), ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partition @676:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 112 / 120
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for partition @679:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) <= 0 || TreePrimitiveSize[T](tree.right.left) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for partition @679:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 113 / 120
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partition @680:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) > 0 || tree.right.isInstanceOf[Leaf] || compare[T](ord, tree.right.value, p) <= 0 || isValidPartition[T](p, tree, ord, partitionSmallerGreater[T](p, tree, partition[T](p, tree.right.left, ord), ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partition @680:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 114 / 120
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partition @684:26...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || !tree.left.isInstanceOf[Leaf] || isValidPartition[T](p, tree, ord, partitionGreaterEmpty[T](p, tree, ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partition @684:26:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 115 / 120
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for partition @686:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) > 0 || TreePrimitiveSize[T](tree.left.right) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for partition @686:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 116 / 120
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partition @687:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) > 0 || isValidPartition[T](p, tree, ord, partitionGreaterSmaller[T](p, tree, partition[T](p, tree.left.right, ord), ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partition @687:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 117 / 120
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for partition @690:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) <= 0 || TreePrimitiveSize[T](tree.left.left) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for partition @690:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 118 / 120
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partition @691:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || tree.isInstanceOf[Leaf] || compare[T](ord, tree.value, p) <= 0 || tree.left.isInstanceOf[Leaf] || compare[T](ord, tree.left.value, p) <= 0 || isValidPartition[T](p, tree, ord, partitionGreaterGreater[T](p, tree, partition[T](p, tree.left.left, ord), ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partition @691:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 119 / 120
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partition @670:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partition @670:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 120 / 120
[[35m Debug  [0m] Generating VCs for functions: insert$0, insert$17
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 120 / 121
[[35m Debug  [0m]  - Now solving 'precond. (call insert[T](({   assert(thiss.isInstanc...)' VC for insert @10:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call insert[T](({   assert(thiss.isInstanc...)' VC for insert @10:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 121 / 121
[[35m Debug  [0m] Generating VCs for functions: getMinTreeElRecursiveStep$0, getMinTreeEl$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 121 / 140
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for getMinTreeElRecursiveStep @740:22...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for getMinTreeElRecursiveStep @740:22:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 122 / 140
[[35m Debug  [0m]  - Now solving 'precond. (call getMinTreeEl[T](l, ord))' VC for getMinTreeElRecursiveStep @744:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val tree: Tree[T] = (tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   })._1
[[35m Debug  [0m]   isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call getMinTreeEl[T](l, ord))' VC for getMinTreeElRecursiveStep @744:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 123 / 140
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for getMinTreeElRecursiveStep @755:13...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   val subTreeMinPair: (Tree[T], T) = getMinTreeEl[T](t._1, ord)
[[35m Debug  [0m]   !(((treeSet[T](t._1).contains(subTreeMinPair._2) && treeGreaterEqThanValue[T](t._1, subTreeMinPair._2, ord)) && compare[T](ord, v, subTreeMinPair._2) >= 0) && treeGreaterEqThanValue[T](t._3, v, ord)) || compare[T](ord, v, subTreeMinPair._2) >= 0 && treeGreaterEqThanValue[T](t._3, v, ord)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for getMinTreeElRecursiveStep @755:13:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 124 / 140
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for getMinTreeEl @806:22...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for getMinTreeEl @806:22:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 125 / 140
[[35m Debug  [0m]  - Now solving 'precond. (call getMinTreeElTrivialCase[T](tree, ord))' VC for getMinTreeEl @806:43...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || !isTreeEmpty[T](leftSubTree[T](tree)) || (isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call getMinTreeElTrivialCase[T](tree, ord))' VC for getMinTreeEl @806:43:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 126 / 140
[[35m Debug  [0m]  - Now solving 'precond. (call getMinTreeElRecursiveStep[T](tree, ord))' VC for getMinTreeEl @807:43...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || (isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call getMinTreeElRecursiveStep[T](tree, ord))' VC for getMinTreeEl @807:43:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 127 / 140
[[35m Debug  [0m]  - Now solving 'body assertion' VC for getMinTreeElRecursiveStep @761:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   val subTreeMinPair: (Tree[T], T) = getMinTreeEl[T](t._1, ord)
[[35m Debug  [0m]   (((((treeSet[T](t._1).contains(subTreeMinPair._2) && treeGreaterEqThanValue[T](t._1, subTreeMinPair._2, ord)) && compare[T](ord, v, subTreeMinPair._2) >= 0) && treeGreaterEqThanValue[T](t._3, v, ord)) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](subTreeMinPair._2, v, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, subTreeMinPair._2, ord)
[[35m Debug  [0m]   }) && treeGreaterEqThanValue[T](tree, subTreeMinPair._2, ord)) && isMinTreeEl[T](tree, ord, subTreeMinPair._2)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for getMinTreeElRecursiveStep @761:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 128 / 140
[[35m Debug  [0m]  - Now solving 'body assertion' VC for getMinTreeElRecursiveStep @772:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   val subTreeMinPair: (Tree[T], T) = getMinTreeEl[T](t._1, ord)
[[35m Debug  [0m]   !((((((treeSet[T](t._1).contains(subTreeMinPair._2) && treeGreaterEqThanValue[T](t._1, subTreeMinPair._2, ord)) && compare[T](ord, v, subTreeMinPair._2) >= 0) && treeGreaterEqThanValue[T](t._3, v, ord)) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](subTreeMinPair._2, v, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, subTreeMinPair._2, ord)
[[35m Debug  [0m]   }) && treeGreaterEqThanValue[T](tree, subTreeMinPair._2, ord)) && isMinTreeEl[T](tree, ord, subTreeMinPair._2)) || (((((treeSet[T](subTreeMinPair._1).subsetOf(treeSet[T](t._1)) && treeSmallerEqThanValue[T](t._1, v, ord)) && treeSmallerEqThanValue[T](subTreeMinPair._1, v, ord)) && treeGreaterEqThanValue[T](t._3, v, ord)) && isBinarySearchTree[T](subTreeMinPair._1, ord)) && isBinarySearchTree[T](t._3, ord)) && isBinarySearchTree[T](Node[T](subTreeMinPair._1, v, t._3), ord)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for getMinTreeElRecursiveStep @772:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 129 / 140
[[35m Debug  [0m]  - Now solving 'body assertion' VC for getMinTreeElRecursiveStep @780:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   val subTreeMinPair: (Tree[T], T) = getMinTreeEl[T](t._1, ord)
[[35m Debug  [0m]   val restOfTree: Tree[T] = Node[T](subTreeMinPair._1, v, t._3)
[[35m Debug  [0m]   !((((((treeSet[T](t._1).contains(subTreeMinPair._2) && treeGreaterEqThanValue[T](t._1, subTreeMinPair._2, ord)) && compare[T](ord, v, subTreeMinPair._2) >= 0) && treeGreaterEqThanValue[T](t._3, v, ord)) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](subTreeMinPair._2, v, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, subTreeMinPair._2, ord)
[[35m Debug  [0m]   }) && treeGreaterEqThanValue[T](tree, subTreeMinPair._2, ord)) && isMinTreeEl[T](tree, ord, subTreeMinPair._2)) || !((((((treeSet[T](subTreeMinPair._1).subsetOf(treeSet[T](t._1)) && treeSmallerEqThanValue[T](t._1, v, ord)) && treeSmallerEqThanValue[T](subTreeMinPair._1, v, ord)) && treeGreaterEqThanValue[T](t._3, v, ord)) && isBinarySearchTree[T](subTreeMinPair._1, ord)) && isBinarySearchTree[T](t._3, ord)) && isBinarySearchTree[T](restOfTree, ord)) || ((treeSet[T](tree) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(v) && treeSet[T](t._1) == treeSet[T](subTreeMinPair._1) ++ Set(subTreeMinPair._2)) && treeSet[T](tree) == treeSet[T](subTreeMinPair._1) ++ Set(subTreeMinPair._2) ++ treeSet[T](t._3) ++ Set(v)) && treeSet[T](restOfTree) == treeSet[T](subTreeMinPair._1) ++ Set(v) ++ treeSet[T](t._3)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for getMinTreeElRecursiveStep @780:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 130 / 140
[[35m Debug  [0m]  - Now solving 'body assertion' VC for getMinTreeElRecursiveStep @788:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   val subTreeMinPair: (Tree[T], T) = getMinTreeEl[T](t._1, ord)
[[35m Debug  [0m]   val restOfTree: Tree[T] = Node[T](subTreeMinPair._1, v, t._3)
[[35m Debug  [0m]   !((((((treeSet[T](t._1).contains(subTreeMinPair._2) && treeGreaterEqThanValue[T](t._1, subTreeMinPair._2, ord)) && compare[T](ord, v, subTreeMinPair._2) >= 0) && treeGreaterEqThanValue[T](t._3, v, ord)) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](subTreeMinPair._2, v, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, subTreeMinPair._2, ord)
[[35m Debug  [0m]   }) && treeGreaterEqThanValue[T](tree, subTreeMinPair._2, ord)) && isMinTreeEl[T](tree, ord, subTreeMinPair._2)) || !((((((treeSet[T](subTreeMinPair._1).subsetOf(treeSet[T](t._1)) && treeSmallerEqThanValue[T](t._1, v, ord)) && treeSmallerEqThanValue[T](subTreeMinPair._1, v, ord)) && treeGreaterEqThanValue[T](t._3, v, ord)) && isBinarySearchTree[T](subTreeMinPair._1, ord)) && isBinarySearchTree[T](t._3, ord)) && isBinarySearchTree[T](restOfTree, ord)) || !(((treeSet[T](tree) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(v) && treeSet[T](t._1) == treeSet[T](subTreeMinPair._1) ++ Set(subTreeMinPair._2)) && treeSet[T](tree) == treeSet[T](subTreeMinPair._1) ++ Set(subTreeMinPair._2) ++ treeSet[T](t._3) ++ Set(v)) && treeSet[T](restOfTree) == treeSet[T](subTreeMinPair._1) ++ Set(v) ++ treeSet[T](t._3)) || ((treeSize[T](tree) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1") && treeSize[T](t._1) == treeSize[T](subTreeMinPair._1) + BigInt("1")) && treeSize[T](tree) == ((treeSize[T](subTreeMinPair._1) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](restOfTree) == (treeSize[T](subTreeMinPair._1) + BigInt("1")) + treeSize[T](t._3)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for getMinTreeElRecursiveStep @788:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 131 / 140
[[35m Debug  [0m]  - Now solving 'non-negative measure' VC for getMinTreeElRecursiveStep @735:3...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val e: BigInt = BigInt("0")
[[35m Debug  [0m]   (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m] } >= BigInt("0") && {
[[35m Debug  [0m]   val e: BigInt = (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   BigInt("0")
[[35m Debug  [0m] } >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'non-negative measure' VC for getMinTreeElRecursiveStep @735:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 132 / 140
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for getMinTreeElRecursiveStep @743:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for getMinTreeElRecursiveStep @743:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 133 / 140
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for getMinTreeElRecursiveStep @744:28...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   {
[[35m Debug  [0m]     val e: BigInt = BigInt("1")
[[35m Debug  [0m]     (BigInt("0") + TreePrimitiveSize[T](t._1)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   } < {
[[35m Debug  [0m]     val e: BigInt = BigInt("0")
[[35m Debug  [0m]     (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   } || {
[[35m Debug  [0m]     val e: BigInt = BigInt("1")
[[35m Debug  [0m]     (BigInt("0") + TreePrimitiveSize[T](t._1)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   } == {
[[35m Debug  [0m]     val e: BigInt = BigInt("0")
[[35m Debug  [0m]     (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   } && {
[[35m Debug  [0m]     val e: BigInt = (BigInt("0") + TreePrimitiveSize[T](t._1)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]     BigInt("1")
[[35m Debug  [0m]   } < {
[[35m Debug  [0m]     val e: BigInt = (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]     BigInt("0")
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for getMinTreeElRecursiveStep @744:28:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 134 / 140
[[35m Debug  [0m]  - Now solving 'body assertion: Inner refinement lifting' VC for getMinTreeElRecursiveStep @747:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val subTreeMinPair: (Tree[T], T) = getMinTreeEl[T]((tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   })._1, ord)
[[35m Debug  [0m]   true
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Inner refinement lifting' VC for getMinTreeElRecursiveStep @747:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 135 / 140
[[35m Debug  [0m]  - Now solving 'postcondition' VC for getMinTreeElRecursiveStep @792:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(l, v, r) =>
[[35m Debug  [0m]       (l, v, r)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val v: T = t._2
[[35m Debug  [0m]   val subTreeMinPair: (Tree[T], T) = getMinTreeEl[T](t._1, ord)
[[35m Debug  [0m]   val restOfTree: Tree[T] = Node[T](subTreeMinPair._1, v, t._3)
[[35m Debug  [0m]   !((((((treeSet[T](t._1).contains(subTreeMinPair._2) && treeGreaterEqThanValue[T](t._1, subTreeMinPair._2, ord)) && compare[T](ord, v, subTreeMinPair._2) >= 0) && treeGreaterEqThanValue[T](t._3, v, ord)) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](subTreeMinPair._2, v, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, subTreeMinPair._2, ord)
[[35m Debug  [0m]   }) && treeGreaterEqThanValue[T](tree, subTreeMinPair._2, ord)) && isMinTreeEl[T](tree, ord, subTreeMinPair._2)) || !((((((treeSet[T](subTreeMinPair._1).subsetOf(treeSet[T](t._1)) && treeSmallerEqThanValue[T](t._1, v, ord)) && treeSmallerEqThanValue[T](subTreeMinPair._1, v, ord)) && treeGreaterEqThanValue[T](t._3, v, ord)) && isBinarySearchTree[T](subTreeMinPair._1, ord)) && isBinarySearchTree[T](t._3, ord)) && isBinarySearchTree[T](restOfTree, ord)) || !(((treeSet[T](tree) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(v) && treeSet[T](t._1) == treeSet[T](subTreeMinPair._1) ++ Set(subTreeMinPair._2)) && treeSet[T](tree) == treeSet[T](subTreeMinPair._1) ++ Set(subTreeMinPair._2) ++ treeSet[T](t._3) ++ Set(v)) && treeSet[T](restOfTree) == treeSet[T](subTreeMinPair._1) ++ Set(v) ++ treeSet[T](t._3)) || !(((treeSize[T](tree) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1") && treeSize[T](t._1) == treeSize[T](subTreeMinPair._1) + BigInt("1")) && treeSize[T](tree) == ((treeSize[T](subTreeMinPair._1) + BigInt("1")) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](restOfTree) == (treeSize[T](subTreeMinPair._1) + BigInt("1")) + treeSize[T](t._3)) || ((isMinTreeEl[T](tree, ord, subTreeMinPair._2) && treeSize[T](restOfTree) + BigInt("1") == treeSize[T](tree)) && isBinarySearchTree[T](restOfTree, ord)) && Set(subTreeMinPair._2) ++ treeSet[T](restOfTree) == treeSet[T](tree)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for getMinTreeElRecursiveStep @792:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 136 / 140
[[35m Debug  [0m]  - Now solving 'non-negative measure' VC for getMinTreeEl @802:3...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || {
[[35m Debug  [0m]   val e: BigInt = BigInt("1")
[[35m Debug  [0m]   (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m] } >= BigInt("0") && {
[[35m Debug  [0m]   val e: BigInt = (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   BigInt("1")
[[35m Debug  [0m] } >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'non-negative measure' VC for getMinTreeEl @802:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 137 / 140
[[35m Debug  [0m]  - Now solving 'postcondition' VC for getMinTreeEl @806:43...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || !isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val res: (Tree[T], T) = getMinTreeElTrivialCase[T](tree, ord)
[[35m Debug  [0m]   isMinTreeEl[T](tree, ord, res._2) && treeSize[T](res._1) + BigInt("1") == treeSize[T](tree) && isBinarySearchTree[T](res._1, ord) && Set(res._2) ++ treeSet[T](res._1) == treeSet[T](tree)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for getMinTreeEl @806:43:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 138 / 140
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for getMinTreeEl @807:43...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val e: BigInt = BigInt("0")
[[35m Debug  [0m]   (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m] } < {
[[35m Debug  [0m]   val e: BigInt = BigInt("1")
[[35m Debug  [0m]   (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m] } || {
[[35m Debug  [0m]   val e: BigInt = BigInt("0")
[[35m Debug  [0m]   (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m] } == {
[[35m Debug  [0m]   val e: BigInt = BigInt("1")
[[35m Debug  [0m]   (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m] } && {
[[35m Debug  [0m]   val e: BigInt = (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   BigInt("0")
[[35m Debug  [0m] } < {
[[35m Debug  [0m]   val e: BigInt = (BigInt("0") + TreePrimitiveSize[T](tree)) + OrderingPrimitiveSize[T](ord)
[[35m Debug  [0m]   BigInt("1")
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for getMinTreeEl @807:43:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 139 / 140
[[35m Debug  [0m]  - Now solving 'postcondition' VC for getMinTreeEl @807:43...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || isTreeEmpty[T](leftSubTree[T](tree)) || {
[[35m Debug  [0m]   val res: (Tree[T], T) = getMinTreeElRecursiveStep[T](tree, ord)
[[35m Debug  [0m]   isMinTreeEl[T](tree, ord, res._2) && treeSize[T](res._1) + BigInt("1") == treeSize[T](tree) && isBinarySearchTree[T](res._1, ord) && Set(res._2) ++ treeSet[T](res._1) == treeSet[T](tree)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for getMinTreeEl @807:43:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 140 / 140
[[35m Debug  [0m] Generating VCs for functions: leftSubTree$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 140 / 141
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for leftSubTree @43:9...
[[35m Debug  [0m] isTreeEmpty[T](tree) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for leftSubTree @43:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 141 / 141
[[35m Debug  [0m] Generating VCs for functions: strictlyMonotonicInverseLemmaSmaller$0, strictlyMonotonicInverseLemmaSmaller$1, strictlyMonotonicInverseLemmaSmaller$2
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 141 / 146
[[35m Debug  [0m]  - Now solving 'precond. (call strictlyMonotonicInverseLemmaSmaller[...)' VC for strictlyMonotonicInverseLemmaSmaller @56:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictlyMonotonicInverseLemmaSmaller[...)' VC for strictlyMonotonicInverseLemmaSmaller @56:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 142 / 146
[[35m Debug  [0m]  - Now solving 'precond. (call strictlyMonotonicInverseLemmaSmaller[... (require 2)' VC for strictlyMonotonicInverseLemmaSmaller @56:3...
[[35m Debug  [0m] compare[T](thiss, x, y) >= 0 || compare[T](thiss, x, y) < 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictlyMonotonicInverseLemmaSmaller[... (require 2)' VC for strictlyMonotonicInverseLemmaSmaller @56:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 143 / 146
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictlyMonotonicInverseLemmaSmaller @56:3...
[[35m Debug  [0m] compare[T](thiss, x, y) >= 0 || {
[[35m Debug  [0m]   val x$3: Unit = strictlyMonotonicInverseLemmaSmaller[T](thiss, x, y)
[[35m Debug  [0m]   compare[T](thiss, y, x) > 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictlyMonotonicInverseLemmaSmaller @56:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 144 / 146
[[35m Debug  [0m]  - Now solving 'body assertion' VC for strictlyMonotonicInverseLemmaSmaller @58:12...
[[35m Debug  [0m] compare[T](thiss, x, y) >= 0 || inverse[T](thiss, x, y)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for strictlyMonotonicInverseLemmaSmaller @58:12:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 145 / 146
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictlyMonotonicInverseLemmaSmaller @56:3...
[[35m Debug  [0m] compare[T](thiss, x, y) >= 0 || !inverse[T](thiss, x, y) || compare[T](thiss, y, x) > 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictlyMonotonicInverseLemmaSmaller @56:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 146 / 146
[[35m Debug  [0m] Generating VCs for functions: isBinarySearchTree$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 146 / 150
[[35m Debug  [0m]  - Now solving 'non-negative measure' VC for isBinarySearchTree @76:3...
[[35m Debug  [0m] TreePrimitiveSize[T](tree) >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'non-negative measure' VC for isBinarySearchTree @76:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 147 / 150
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for isBinarySearchTree @79:31...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || TreePrimitiveSize[T](tree.left) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for isBinarySearchTree @79:31:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 148 / 150
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for isBinarySearchTree @79:56...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || !isBinarySearchTree[T](tree.left, ord) || TreePrimitiveSize[T](tree.right) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for isBinarySearchTree @79:56:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 149 / 150
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for isBinarySearchTree @77:17...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for isBinarySearchTree @77:17:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 150 / 150
[[35m Debug  [0m] Generating VCs for functions: partitionSmallerGreater$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 150 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerGreater @294:21...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerGreater @294:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 151 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @295:22...
[[35m Debug  [0m] !((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @295:22:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 152 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @296:35...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @296:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 153 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerGreater @296:21...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) || !isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerGreater @296:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 154 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @297:41...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) && compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @297:41:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 155 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](rightSubTree[T](tree)))' VC for partitionSmallerGreater @297:29...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) && compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0) || !isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](rightSubTree[T](tree)))' VC for partitionSmallerGreater @297:29:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 156 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @301:35...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerGreater @301:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 157 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerGreater @301:21...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerGreater @301:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 158 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerGreater @302:21...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) < 0 || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerGreater @302:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 159 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerGreater @303:24...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerGreater @303:24:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 160 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerGreater @311:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !(inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) || compare[T](ord, p, a) >= 0 && treeSmallerEqThanValue[T](t._1, a, ord)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerGreater @311:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 161 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerGreater @371:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)) || !((((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._1))) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeGreaterEqThanValue[T](subParts._1, a, ord)) && isBinarySearchTree[T](Node[T](t._1, a, t._1), ord)) || compare[T](ord, p, a) < 0 || compare[T](ord, p, a) >= 0 && treeSmallerEqThanValue[T](t._1, a, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerGreater @371:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 162 / 175
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionSmallerGreater @393:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)) || !((((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._1))) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeGreaterEqThanValue[T](subParts._1, a, ord)) && isBinarySearchTree[T](Node[T](t._1, a, t._1), ord)) || !(((compare[T](ord, p, a) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, a, t._1), p, ord)) || !((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, t._3), ord)) || compare[T](ord, b, p) < 0 || compare[T](ord, b, p) >= 0 && treeGreaterEqThanValue[T](t._3, b, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionSmallerGreater @393:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 163 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @301:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || (compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @301:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 164 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @308:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   (inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @308:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 165 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @337:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     (((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @337:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 166 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @353:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || (((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @353:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 167 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @366:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)) || (((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._1))) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeGreaterEqThanValue[T](subParts._1, a, ord)) && isBinarySearchTree[T](Node[T](t._1, a, t._1), ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @366:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 168 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @377:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)) || !((((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._1))) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeGreaterEqThanValue[T](subParts._1, a, ord)) && isBinarySearchTree[T](Node[T](t._1, a, t._1), ord)) || ((compare[T](ord, p, a) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, a, t._1), p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @377:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 169 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @388:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)) || !((((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._1))) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeGreaterEqThanValue[T](subParts._1, a, ord)) && isBinarySearchTree[T](Node[T](t._1, a, t._1), ord)) || !(((compare[T](ord, p, a) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, a, t._1), p, ord)) || (((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, t._3), ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @388:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 170 / 175
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerGreater @399:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)) || !((((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._1))) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeGreaterEqThanValue[T](subParts._1, a, ord)) && isBinarySearchTree[T](Node[T](t._1, a, t._1), ord)) || !(((compare[T](ord, p, a) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, a, t._1), p, ord)) || !((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, t._3), ord)) || ((compare[T](ord, b, p) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, b, t._3, ord)
[[35m Debug  [0m]       treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]     }) && treeGreaterEqThanValue[T](pr, p, ord)) && treeGreaterEqThanValue[T](Node[T](pr, b, t._3), p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerGreater @399:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 171 / 175
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionSmallerGreater @306:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionSmallerGreater @306:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 172 / 175
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionSmallerGreater @315:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || t._3.isInstanceOf[Node]
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionSmallerGreater @315:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 173 / 175
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionSmallerGreater @316:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: Boolean = (inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   true
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionSmallerGreater @316:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 174 / 175
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partitionSmallerGreater @399:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) >= 0 && inverse[T](ord, treeRootValue[T](tree), p)) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     !((((((((treeSet[T](Node[T](t._1, a, t._1)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) && treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(a) ++ treeSet[T](pr) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](tree) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](t._1, a, t._1)) ++ treeSet[T](Node[T](pr, b, t._3)) == treeSet[T](tree)) || !((((((((treeSize[T](Node[T](t._1, a, t._1)) == (treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](pr) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == ((((treeSize[T](t._1) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](pr)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](tree) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](t._1, a, t._1)) + treeSize[T](Node[T](pr, b, t._3)) == treeSize[T](tree)) || !((((((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](subParts._1, ord)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._1))) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeGreaterEqThanValue[T](subParts._1, a, ord)) && isBinarySearchTree[T](Node[T](t._1, a, t._1), ord)) || !(((compare[T](ord, p, a) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]       treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]     }) && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](Node[T](t._1, a, t._1), p, ord)) || !((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, t._3), ord)) || !(((compare[T](ord, b, p) >= 0 && {
[[35m Debug  [0m]       val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, b, t._3, ord)
[[35m Debug  [0m]       treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]     }) && treeGreaterEqThanValue[T](pr, p, ord)) && treeGreaterEqThanValue[T](Node[T](pr, b, t._3), p, ord)) || isValidPartition[T](p, tree, ord, (Node[T](t._1, a, t._1), Node[T](pr, b, t._3)))
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partitionSmallerGreater @399:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 175 / 175
[[35m Debug  [0m] Generating VCs for functions: logLemmaInPowerForm$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 175 / 176
[[35m Debug  [0m]  - Now solving 'postcondition' VC for logLemmaInPowerForm @29:5...
[[35m Debug  [0m] x < BigInt("2") || y < BigInt("2") || {
[[35m Debug  [0m]   val rhsSubExp: BigInt = (x + y) - BigInt("1")
[[35m Debug  [0m]   (BigInt("2") * x) * y <= rhsSubExp * rhsSubExp
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for logLemmaInPowerForm @29:5:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 176 / 176
[[35m Debug  [0m] Generating VCs for functions: strictlyMonotonicInverseLemmaGreater$0, strictlyMonotonicInverseLemmaGreater$2, strictlyMonotonicInverseLemmaGreater$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 176 / 181
[[35m Debug  [0m]  - Now solving 'body assertion' VC for strictlyMonotonicInverseLemmaGreater @50:12...
[[35m Debug  [0m] compare[T](thiss, x, y) <= 0 || inverse[T](thiss, x, y)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for strictlyMonotonicInverseLemmaGreater @50:12:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 177 / 181
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictlyMonotonicInverseLemmaGreater @48:3...
[[35m Debug  [0m] compare[T](thiss, x, y) <= 0 || !inverse[T](thiss, x, y) || compare[T](thiss, y, x) < 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictlyMonotonicInverseLemmaGreater @48:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 178 / 181
[[35m Debug  [0m]  - Now solving 'precond. (call strictlyMonotonicInverseLemmaGreater[...)' VC for strictlyMonotonicInverseLemmaGreater @48:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictlyMonotonicInverseLemmaGreater[...)' VC for strictlyMonotonicInverseLemmaGreater @48:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 179 / 181
[[35m Debug  [0m]  - Now solving 'precond. (call strictlyMonotonicInverseLemmaGreater[... (require 2)' VC for strictlyMonotonicInverseLemmaGreater @48:3...
[[35m Debug  [0m] compare[T](thiss, x, y) <= 0 || compare[T](thiss, x, y) > 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictlyMonotonicInverseLemmaGreater[... (require 2)' VC for strictlyMonotonicInverseLemmaGreater @48:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 180 / 181
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictlyMonotonicInverseLemmaGreater @48:3...
[[35m Debug  [0m] compare[T](thiss, x, y) <= 0 || {
[[35m Debug  [0m]   val x$2: Unit = strictlyMonotonicInverseLemmaGreater[T](thiss, x, y)
[[35m Debug  [0m]   compare[T](thiss, y, x) < 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictlyMonotonicInverseLemmaGreater @48:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 181 / 181
[[35m Debug  [0m] Generating VCs for functions: monotonicInverseLemmaSmaller$0, monotonicInverseLemmaSmaller$1, monotonicInverseLemmaSmaller$2
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 181 / 186
[[35m Debug  [0m]  - Now solving 'precond. (call monotonicInverseLemmaSmaller[T](({   ...)' VC for monotonicInverseLemmaSmaller @72:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call monotonicInverseLemmaSmaller[T](({   ...)' VC for monotonicInverseLemmaSmaller @72:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 182 / 186
[[35m Debug  [0m]  - Now solving 'precond. (call monotonicInverseLemmaSmaller[T](({   ... (require 2)' VC for monotonicInverseLemmaSmaller @72:3...
[[35m Debug  [0m] compare[T](thiss, x, y) > 0 || compare[T](thiss, x, y) <= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call monotonicInverseLemmaSmaller[T](({   ... (require 2)' VC for monotonicInverseLemmaSmaller @72:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 183 / 186
[[35m Debug  [0m]  - Now solving 'postcondition' VC for monotonicInverseLemmaSmaller @72:3...
[[35m Debug  [0m] compare[T](thiss, x, y) > 0 || {
[[35m Debug  [0m]   val x$5: Unit = monotonicInverseLemmaSmaller[T](thiss, x, y)
[[35m Debug  [0m]   compare[T](thiss, y, x) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for monotonicInverseLemmaSmaller @72:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 184 / 186
[[35m Debug  [0m]  - Now solving 'body assertion' VC for monotonicInverseLemmaSmaller @74:12...
[[35m Debug  [0m] compare[T](thiss, x, y) > 0 || inverse[T](thiss, x, y)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for monotonicInverseLemmaSmaller @74:12:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 185 / 186
[[35m Debug  [0m]  - Now solving 'postcondition' VC for monotonicInverseLemmaSmaller @72:3...
[[35m Debug  [0m] compare[T](thiss, x, y) > 0 || !inverse[T](thiss, x, y) || compare[T](thiss, y, x) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for monotonicInverseLemmaSmaller @72:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 186 / 186
[[35m Debug  [0m] Generating VCs for functions: treeSmallerEqThanValue$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 186 / 186
[[35m Debug  [0m] Generating VCs for functions: assume$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 186 / 186
[[35m Debug  [0m] Generating VCs for functions: treeSize$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 186 / 192
[[35m Debug  [0m]  - Now solving 'non-negative measure' VC for treeSize @14:3...
[[35m Debug  [0m] TreePrimitiveSize[T](tree) >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'non-negative measure' VC for treeSize @14:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 187 / 192
[[35m Debug  [0m]  - Now solving 'postcondition' VC for treeSize @15:20...
[[35m Debug  [0m] !tree.isInstanceOf[Leaf] || BigInt("0") >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for treeSize @15:20:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 188 / 192
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for treeSize @16:39...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || TreePrimitiveSize[T](tree.left) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for treeSize @16:39:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 189 / 192
[[35m Debug  [0m]  - Now solving 'measure decreases' VC for treeSize @16:53...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || TreePrimitiveSize[T](tree.right) < TreePrimitiveSize[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'measure decreases' VC for treeSize @16:53:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 190 / 192
[[35m Debug  [0m]  - Now solving 'postcondition' VC for treeSize @16:27...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || (BigInt("1") + treeSize[T](tree.left)) + treeSize[T](tree.right) >= BigInt("0")
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for treeSize @16:27:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 191 / 192
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for treeSize @14:45...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for treeSize @14:45:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 192 / 192
[[35m Debug  [0m] Generating VCs for functions: createEmpty$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 192 / 195
[[35m Debug  [0m]  - Now solving 'precond. (call isEmpty[T](x$1))' VC for createEmpty @14:15...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call isEmpty[T](x$1))' VC for createEmpty @14:15:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 193 / 195
[[35m Debug  [0m]  - Now solving 'class invariant' VC for createEmpty @13:5...
[[35m Debug  [0m] inv[T](SplayHeap[T](Leaf[T](), ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'class invariant' VC for createEmpty @13:5:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 194 / 195
[[35m Debug  [0m]  - Now solving 'postcondition' VC for createEmpty @12:3...
[[35m Debug  [0m] isEmpty[T](SplayHeap[T](Leaf[T](), ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for createEmpty @12:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 195 / 195
[[35m Debug  [0m] Generating VCs for functions: minLaw$0, minLaw$3, minLaw$1, minLaw$2
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 195 / 202
[[35m Debug  [0m]  - Now solving 'precond. (call get[T](min[T](thiss)))' VC for minLaw @55:62...
[[35m Debug  [0m] isEmpty[T](thiss) && (!isEmpty[T](delMin[T](thiss)) || !isEmpty[T](min[T](thiss))) || isEmpty[T](thiss) || !nonEmpty[T](min[T](thiss)) || {
[[35m Debug  [0m]   val set: Set[T] = set[T](thiss)
[[35m Debug  [0m]   (isDefined[T](min[T](thiss))): @ghost 
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call get[T](min[T](thiss)))' VC for minLaw @55:62:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 196 / 202
[[35m Debug  [0m]  - Now solving 'precond. (call get[T](min[T](thiss)))' VC for minLaw @56:52...
[[35m Debug  [0m] isEmpty[T](thiss) && (!isEmpty[T](delMin[T](thiss)) || !isEmpty[T](min[T](thiss))) || isEmpty[T](thiss) || !nonEmpty[T](min[T](thiss)) || !isMinSetEl[T](set[T](thiss), ordering[T](thiss), get[T](min[T](thiss))) || size[T](delMin[T](thiss)) + BigInt("1") != size[T](thiss) || (isDefined[T](min[T](thiss))): @ghost 
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call get[T](min[T](thiss)))' VC for minLaw @56:52:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 197 / 202
[[35m Debug  [0m]  - Now solving 'precond. (call minLaw[T](({   assert(thiss.isInstanc...)' VC for minLaw @53:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call minLaw[T](({   assert(thiss.isInstanc...)' VC for minLaw @53:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 198 / 202
[[35m Debug  [0m]  - Now solving 'precond. (call minLaw[T](({   assert(thiss.isInstanc...)' VC for minLaw @53:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call minLaw[T](({   assert(thiss.isInstanc...)' VC for minLaw @53:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 199 / 202
[[35m Debug  [0m]  - Now solving 'postcondition' VC for minLaw @53:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || minLaw[T](thiss) && (!isEmpty[T](thiss) || isEmpty[T](delMin[T](thiss)) && isEmpty[T](min[T](thiss))) && (isEmpty[T](thiss) || nonEmpty[T](min[T](thiss)) && isMinSetEl[T](set[T](thiss), ordering[T](thiss), get[T](min[T](thiss))) && size[T](delMin[T](thiss)) + BigInt("1") == size[T](thiss) && set[T](delMin[T](thiss)) ++ Set(get[T](min[T](thiss))) == set[T](thiss))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for minLaw @53:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 200 / 202
[[35m Debug  [0m]  - Now solving 'postcondition' VC for minLaw @53:3...
[[35m Debug  [0m] thiss.isInstanceOf[SplayHeap] || minLaw[T](thiss) && (!isEmpty[T](thiss) || isEmpty[T](delMin[T](thiss)) && isEmpty[T](min[T](thiss))) && (isEmpty[T](thiss) || nonEmpty[T](min[T](thiss)) && isMinSetEl[T](set[T](thiss), ordering[T](thiss), get[T](min[T](thiss))) && size[T](delMin[T](thiss)) + BigInt("1") == size[T](thiss) && set[T](delMin[T](thiss)) ++ Set(get[T](min[T](thiss))) == set[T](thiss))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for minLaw @53:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 201 / 202
[[35m Debug  [0m]  - Now solving 'law' VC for minLaw @53:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || (!isEmpty[T](thiss) || isEmpty[T](delMin[T](thiss)) && isEmpty[T](min[T](thiss))) && (isEmpty[T](thiss) || nonEmpty[T](min[T](thiss)) && isMinSetEl[T](set[T](thiss), ordering[T](thiss), get[T](min[T](thiss))) && size[T](delMin[T](thiss)) + BigInt("1") == size[T](thiss) && set[T](delMin[T](thiss)) ++ Set(get[T](min[T](thiss))) == set[T](thiss))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'law' VC for minLaw @53:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 202 / 202
[[35m Debug  [0m] Generating VCs for functions: subtreeSmallerOrderingTransitivityLemma$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 202 / 206
[[35m Debug  [0m]  - Now solving 'precond. (call nonStrictTransitivityLemma[T](ord, el...)' VC for subtreeSmallerOrderingTransitivityLemma @125:11...
[[35m Debug  [0m] compare[T](ord, nodeValue, smallerValue) < 0 || !treeGreaterEqThanValue[T](rightTree, nodeValue, ord) || {
[[35m Debug  [0m]   val set: Set[T] = treeSet[T](rightTree)
[[35m Debug  [0m]   compare[T](ord, el, nodeValue) < 0 || compare[T](ord, el, nodeValue) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call nonStrictTransitivityLemma[T](ord, el...)' VC for subtreeSmallerOrderingTransitivityLemma @125:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 203 / 206
[[35m Debug  [0m]  - Now solving 'precond. (call nonStrictTransitivityLemma[T](ord, el... (require 2)' VC for subtreeSmallerOrderingTransitivityLemma @125:11...
[[35m Debug  [0m] compare[T](ord, nodeValue, smallerValue) < 0 || !treeGreaterEqThanValue[T](rightTree, nodeValue, ord) || {
[[35m Debug  [0m]   val set: Set[T] = treeSet[T](rightTree)
[[35m Debug  [0m]   compare[T](ord, el, nodeValue) < 0 || compare[T](ord, nodeValue, smallerValue) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call nonStrictTransitivityLemma[T](ord, el... (require 2)' VC for subtreeSmallerOrderingTransitivityLemma @125:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 204 / 206
[[35m Debug  [0m]  - Now solving 'body assertion' VC for subtreeSmallerOrderingTransitivityLemma @122:7...
[[35m Debug  [0m] compare[T](ord, nodeValue, smallerValue) < 0 || !treeGreaterEqThanValue[T](rightTree, nodeValue, ord) || compare[T](ord, nodeValue, smallerValue) >= 0 && setForall[T](treeSet[T](rightTree), (el: T) => compare[T](ord, el, nodeValue) >= 0 && {
[[35m Debug  [0m]   val tmp: Unit = nonStrictTransitivityLemma[T](ord, el, nodeValue, smallerValue)
[[35m Debug  [0m]   compare[T](ord, el, smallerValue) >= 0
[[35m Debug  [0m] })
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for subtreeSmallerOrderingTransitivityLemma @122:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 205 / 206
[[35m Debug  [0m]  - Now solving 'postcondition' VC for subtreeSmallerOrderingTransitivityLemma @121:5...
[[35m Debug  [0m] compare[T](ord, nodeValue, smallerValue) < 0 || !treeGreaterEqThanValue[T](rightTree, nodeValue, ord) || !(compare[T](ord, nodeValue, smallerValue) >= 0 && setForall[T](treeSet[T](rightTree), (el: T) => compare[T](ord, el, nodeValue) >= 0 && {
[[35m Debug  [0m]   val tmp: Unit = nonStrictTransitivityLemma[T](ord, el, nodeValue, smallerValue)
[[35m Debug  [0m]   compare[T](ord, el, smallerValue) >= 0
[[35m Debug  [0m] })) || treeGreaterEqThanValue[T](rightTree, smallerValue, ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for subtreeSmallerOrderingTransitivityLemma @121:5:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 206 / 206
[[35m Debug  [0m] Generating VCs for functions: partitionSmallerSmaller$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 206 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerSmaller @176:21...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerSmaller @176:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 207 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @177:22...
[[35m Debug  [0m] !((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @177:22:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 208 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @178:35...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @178:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 209 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @178:21...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) || !isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @178:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 210 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @179:42...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) && compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @179:42:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 211 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @179:29...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) && !isTreeEmpty[T](rightSubTree[T](tree))) && compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) <= 0) || !isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @179:29:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 212 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerSmaller @183:21...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerSmaller @183:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 213 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerSmaller @184:24...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !inverse[T](ord, treeRootValue[T](tree), p) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerSmaller @184:24:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 214 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @185:35...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @185:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 215 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @185:21...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) || !isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @185:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 216 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @186:38...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerSmaller @186:38:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 217 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @186:24...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) || !isTreeEmpty[T](rightSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](rightSubTree[T](tree)))' VC for partitionSmallerSmaller @186:24:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 218 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerSmaller @193:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !(inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) || compare[T](ord, p, a) >= 0 && treeSmallerEqThanValue[T](t._1, a, ord)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerSmaller @193:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 219 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerSmaller @262:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || !(((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)) || {
[[35m Debug  [0m]       val secondGreater: Boolean = treeGreaterEqThanValue[T](y, p, ord)
[[35m Debug  [0m]       val secondBST: Boolean = isBinarySearchTree[T](y, ord)
[[35m Debug  [0m]       !(secondGreater && secondBST) || !(((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](t._1, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._1, a, ord)) && isBinarySearchTree[T](_1_left, ord)) || !(treeSmallerEqThanValue[T](t._1, b, ord) && t) || compare[T](ord, b, a) >= 0 && treeSmallerEqThanValue[T](t._1, a, ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerSmaller @262:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 220 / 234
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerSmaller @279:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || !(((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)) || {
[[35m Debug  [0m]       val secondGreater: Boolean = treeGreaterEqThanValue[T](y, p, ord)
[[35m Debug  [0m]       val secondBST: Boolean = isBinarySearchTree[T](y, ord)
[[35m Debug  [0m]       !(secondGreater && secondBST) || !(((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](t._1, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._1, a, ord)) && isBinarySearchTree[T](_1_left, ord)) || !((((((((treeSmallerEqThanValue[T](t._1, b, ord) && t) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](b, a, t._1, ord)
[[35m Debug  [0m]         treeSmallerEqThanValue[T](t._1, b, ord)
[[35m Debug  [0m]       }) && treeSmallerEqThanValue[T](_1_left, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](subParts._1, ord)) && isBinarySearchTree[T](Node[T](_1_left, b, t._1), ord)) || !((compare[T](ord, p, b) >= 0 && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](_1_left, b, ord)) || compare[T](ord, p, b) >= 0 && treeSmallerEqThanValue[T](_1_left, b, ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerSmaller @279:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 221 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @183:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || ((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @183:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 222 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @190:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   (inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @190:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 223 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @224:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     ((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @224:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 224 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @240:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || ((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @240:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 225 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @246:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || !(((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)) || {
[[35m Debug  [0m]       val secondGreater: Boolean = treeGreaterEqThanValue[T](y, p, ord)
[[35m Debug  [0m]       val secondBST: Boolean = isBinarySearchTree[T](y, ord)
[[35m Debug  [0m]       secondGreater && secondBST
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @246:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 226 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @256:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || !(((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)) || {
[[35m Debug  [0m]       val secondGreater: Boolean = treeGreaterEqThanValue[T](y, p, ord)
[[35m Debug  [0m]       val secondBST: Boolean = isBinarySearchTree[T](y, ord)
[[35m Debug  [0m]       !(secondGreater && secondBST) || ((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](t._1, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._1, a, ord)) && isBinarySearchTree[T](_1_left, ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @256:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 227 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @272:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || !(((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)) || {
[[35m Debug  [0m]       val secondGreater: Boolean = treeGreaterEqThanValue[T](y, p, ord)
[[35m Debug  [0m]       val secondBST: Boolean = isBinarySearchTree[T](y, ord)
[[35m Debug  [0m]       !(secondGreater && secondBST) || !(((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](t._1, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._1, a, ord)) && isBinarySearchTree[T](_1_left, ord)) || (((((((treeSmallerEqThanValue[T](t._1, b, ord) && t) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](b, a, t._1, ord)
[[35m Debug  [0m]         treeSmallerEqThanValue[T](t._1, b, ord)
[[35m Debug  [0m]       }) && treeSmallerEqThanValue[T](_1_left, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](subParts._1, ord)) && isBinarySearchTree[T](Node[T](_1_left, b, t._1), ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @272:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 228 / 234
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerSmaller @284:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || !(((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)) || {
[[35m Debug  [0m]       val secondGreater: Boolean = treeGreaterEqThanValue[T](y, p, ord)
[[35m Debug  [0m]       val secondBST: Boolean = isBinarySearchTree[T](y, ord)
[[35m Debug  [0m]       !(secondGreater && secondBST) || !(((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](t._1, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._1, a, ord)) && isBinarySearchTree[T](_1_left, ord)) || !((((((((treeSmallerEqThanValue[T](t._1, b, ord) && t) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](b, a, t._1, ord)
[[35m Debug  [0m]         treeSmallerEqThanValue[T](t._1, b, ord)
[[35m Debug  [0m]       }) && treeSmallerEqThanValue[T](_1_left, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](subParts._1, ord)) && isBinarySearchTree[T](Node[T](_1_left, b, t._1), ord)) || (((compare[T](ord, p, b) >= 0 && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](_1_left, b, ord)) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, b, _1_left, ord)
[[35m Debug  [0m]         treeSmallerEqThanValue[T](_1_left, p, ord)
[[35m Debug  [0m]       }) && treeSmallerEqThanValue[T](Node[T](_1_left, b, t._1), p, ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerSmaller @284:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 229 / 234
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionSmallerSmaller @188:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionSmallerSmaller @188:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 230 / 234
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionSmallerSmaller @197:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || t._3.isInstanceOf[Node]
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionSmallerSmaller @197:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 231 / 234
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionSmallerSmaller @198:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: Boolean = (inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   true
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionSmallerSmaller @198:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 232 / 234
[[35m Debug  [0m]  - Now solving 'body assertion: Inner refinement lifting' VC for partitionSmallerSmaller @204:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val b: T = (t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     })._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     true
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Inner refinement lifting' VC for partitionSmallerSmaller @204:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 233 / 234
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partitionSmallerSmaller @284:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || isTreeEmpty[T](rightSubTree[T](tree)) || compare[T](ord, treeRootValue[T](rightSubTree[T](tree)), p) > 0 || !isValidPartition[T](p, rightSubTree[T](rightSubTree[T](tree)), ord, subParts) || !(((inverse[T](ord, treeRootValue[T](tree), p) && compare[T](ord, p, treeRootValue[T](tree)) >= 0) && inverse[T](ord, treeRootValue[T](rightSubTree[T](tree)), p)) && compare[T](ord, p, treeRootValue[T](rightSubTree[T](tree))) >= 0) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     treeSmallerEqThanValue[T](t._1, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], T, Tree[T]) = t._3 match {
[[35m Debug  [0m]       case Node(bl, b, br) =>
[[35m Debug  [0m]         (bl, b, br)
[[35m Debug  [0m]     }
[[35m Debug  [0m]     val b: T = t._2
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val y: Tree[T] = subParts._2
[[35m Debug  [0m]     val t: Boolean = treeSet[T](t._3).contains(b) && compare[T](ord, b, a) >= 0
[[35m Debug  [0m]     val _1_left: Tree[T] = Node[T](t._1, a, t._1)
[[35m Debug  [0m]     !(((((((((treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](_1_left) ++ treeSet[T](subParts._1) ++ Set(b) && treeSet[T](_1_left) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1)) && treeSet[T](Node[T](_1_left, b, t._1)) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](y) == treeSet[T](y)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._1) ++ treeSet[T](subParts._1) ++ Set(b) ++ treeSet[T](y)) && treeSet[T](t._3) == treeSet[T](y) ++ treeSet[T](subParts._1)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(b)) && treeSet[T](t._3) == treeSet[T](t._1) ++ treeSet[T](y) ++ treeSet[T](subParts._1) ++ Set(b)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](t._1) ++ Set(a) ++ treeSet[T](t._3)) && treeSet[T](Node[T](_1_left, b, t._1)) ++ treeSet[T](y) == treeSet[T](tree)) || !(((((((((treeSize[T](Node[T](_1_left, b, t._1)) == (treeSize[T](_1_left) + treeSize[T](subParts._1)) + BigInt("1") && treeSize[T](_1_left) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) && treeSize[T](Node[T](_1_left, b, t._1)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](y) == treeSize[T](y)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == ((((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._1)) + treeSize[T](subParts._1)) + BigInt("1")) + treeSize[T](y)) && treeSize[T](t._3) == treeSize[T](y) + treeSize[T](subParts._1)) && treeSize[T](t._3) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._3) == ((treeSize[T](t._1) + treeSize[T](y)) + treeSize[T](subParts._1)) + BigInt("1")) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](Node[T](_1_left, b, t._1)) + treeSize[T](y) == treeSize[T](tree)) || {
[[35m Debug  [0m]       val secondGreater: Boolean = treeGreaterEqThanValue[T](y, p, ord)
[[35m Debug  [0m]       val secondBST: Boolean = isBinarySearchTree[T](y, ord)
[[35m Debug  [0m]       !(secondGreater && secondBST) || !(((((isBinarySearchTree[T](t._1, ord) && isBinarySearchTree[T](t._1, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._1, a, ord)) && isBinarySearchTree[T](_1_left, ord)) || !((((((((treeSmallerEqThanValue[T](t._1, b, ord) && t) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](b, a, t._1, ord)
[[35m Debug  [0m]         treeSmallerEqThanValue[T](t._1, b, ord)
[[35m Debug  [0m]       }) && treeSmallerEqThanValue[T](_1_left, b, ord)) && treeSet[T](subParts._1).subsetOf(treeSet[T](t._3))) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeGreaterEqThanValue[T](subParts._1, b, ord)) && isBinarySearchTree[T](subParts._1, ord)) && isBinarySearchTree[T](Node[T](_1_left, b, t._1), ord)) || !((((compare[T](ord, p, b) >= 0 && treeSmallerEqThanValue[T](subParts._1, p, ord)) && treeSmallerEqThanValue[T](_1_left, b, ord)) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, b, _1_left, ord)
[[35m Debug  [0m]         treeSmallerEqThanValue[T](_1_left, p, ord)
[[35m Debug  [0m]       }) && treeSmallerEqThanValue[T](Node[T](_1_left, b, t._1), p, ord)) || isValidPartition[T](p, tree, ord, (Node[T](_1_left, b, t._1), y))
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partitionSmallerSmaller @284:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 234 / 234
[[35m Debug  [0m] Generating VCs for functions: partitionSmallerEmpty$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 234 / 240
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerEmpty @156:21...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionSmallerEmpty @156:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 235 / 240
[[35m Debug  [0m]  - Now solving 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerEmpty @157:21...
[[35m Debug  [0m] !((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) <= 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call rightSubTree[T](tree))' VC for partitionSmallerEmpty @157:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 236 / 240
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerEmpty @164:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || !isTreeEmpty[T](rightSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !(inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) || compare[T](ord, p, a) >= 0 && treeSmallerEqThanValue[T](t._1, a, ord)
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeGreaterOrderingTransitivityLem...)' VC for partitionSmallerEmpty @164:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 237 / 240
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionSmallerEmpty @161:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || !isTreeEmpty[T](rightSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   (inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     setForall[T](treeSet[T](t._1), (el: T) => compare[T](ord, p, el) >= 0)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionSmallerEmpty @161:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 238 / 240
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionSmallerEmpty @159:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || !isTreeEmpty[T](rightSubTree[T](tree)) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionSmallerEmpty @159:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 239 / 240
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partitionSmallerEmpty @160:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) > 0 || !isTreeEmpty[T](rightSubTree[T](tree)) || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   !((inverse[T](ord, a, p) && compare[T](ord, p, a) >= 0) && {
[[35m Debug  [0m]     val tmp: Unit = subtreeGreaterOrderingTransitivityLemma[T](p, a, t._1, ord)
[[35m Debug  [0m]     setForall[T](treeSet[T](t._1), (el: T) => compare[T](ord, p, el) >= 0)
[[35m Debug  [0m]   }) || isValidPartition[T](p, tree, ord, (tree, Leaf[T]()))
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partitionSmallerEmpty @160:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 240 / 240
[[35m Debug  [0m] Generating VCs for functions: isTreeEmpty$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 240 / 243
[[35m Debug  [0m]  - Now solving 'postcondition' VC for isTreeEmpty @23:20...
[[35m Debug  [0m] !tree.isInstanceOf[Leaf] || true == (treeSize[T](tree) == BigInt("0"))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for isTreeEmpty @23:20:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 241 / 243
[[35m Debug  [0m]  - Now solving 'postcondition' VC for isTreeEmpty @24:15...
[[35m Debug  [0m] tree.isInstanceOf[Leaf] || false == (treeSize[T](tree) == BigInt("0"))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for isTreeEmpty @24:15:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 242 / 243
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for isTreeEmpty @22:49...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for isTreeEmpty @22:49:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 243 / 243
[[35m Debug  [0m] Generating VCs for functions: partitionGreaterGreater$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 243 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](tree))' VC for partitionGreaterGreater @541:21...
[[35m Debug  [0m] !(isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](tree))' VC for partitionGreaterGreater @541:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 244 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @542:22...
[[35m Debug  [0m] !((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @542:22:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 245 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @543:35...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @543:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 246 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterGreater @543:21...
[[35m Debug  [0m] !(((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) || !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterGreater @543:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 247 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @544:41...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) && compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @544:41:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 248 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](leftSubTree[T](tree)))' VC for partitionGreaterGreater @544:29...
[[35m Debug  [0m] !((((isBinarySearchTree[T](tree, ord) && !isTreeEmpty[T](tree)) && compare[T](ord, treeRootValue[T](tree), p) > 0) && !isTreeEmpty[T](leftSubTree[T](tree))) && compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) > 0) || !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](leftSubTree[T](tree)))' VC for partitionGreaterGreater @544:29:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 249 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @548:35...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || !isTreeEmpty[T](tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call leftSubTree[T](tree))' VC for partitionGreaterGreater @548:35:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 250 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterGreater @548:21...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || !isTreeEmpty[T](leftSubTree[T](tree))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call treeRootValue[T](leftSubTree[T](tree)))' VC for partitionGreaterGreater @548:21:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 251 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterGreater @557:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   compare[T](ord, t._2, p) < 0 || {
[[35m Debug  [0m]     val nodeValue: T = t._2
[[35m Debug  [0m]     compare[T](ord, nodeValue, p) >= 0 && treeGreaterEqThanValue[T](t._3, nodeValue, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterGreater @557:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 252 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterGreater @636:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || !isBinarySearchTree[T](subParts._1, ord) || !treeSmallerEqThanValue[T](subParts._1, p, ord) || !((((((isBinarySearchTree[T](t._3, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](t._3, a, ord)) && isBinarySearchTree[T](_2_right, ord)) || {
[[35m Debug  [0m]       val t: Boolean = (((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](_2_right, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](t._1).contains(b)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)
[[35m Debug  [0m]       compare[T](ord, a, b) < 0 || compare[T](ord, a, b) >= 0 && treeGreaterEqThanValue[T](t._3, a, ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterGreater @636:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 253 / 268
[[35m Debug  [0m]  - Now solving 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterGreater @648:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || !isBinarySearchTree[T](subParts._1, ord) || !treeSmallerEqThanValue[T](subParts._1, p, ord) || !((((((isBinarySearchTree[T](t._3, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](t._3, a, ord)) && isBinarySearchTree[T](_2_right, ord)) || {
[[35m Debug  [0m]       val t: Boolean = (((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](_2_right, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](t._1).contains(b)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)
[[35m Debug  [0m]       val t: Boolean = ((compare[T](ord, a, b) >= 0 && {
[[35m Debug  [0m]         val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](b, a, t._3, ord)
[[35m Debug  [0m]         treeGreaterEqThanValue[T](t._3, b, ord)
[[35m Debug  [0m]       }) && treeGreaterEqThanValue[T](_2_right, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, _2_right), ord)
[[35m Debug  [0m]       !t || !(treeGreaterEqThanValue[T](pr, p, ord) && compare[T](ord, b, p) >= 0) || compare[T](ord, b, p) >= 0 && treeGreaterEqThanValue[T](_2_right, b, ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call subtreeSmallerOrderingTransitivityLem...)' VC for partitionGreaterGreater @648:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 254 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @548:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @548:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 255 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @555:9...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val ar: Tree[T] = t._3
[[35m Debug  [0m]   compare[T](ord, t._2, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, t._2, ar, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](ar, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @555:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 256 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @585:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     ((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @585:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 257 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @603:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || ((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @603:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 258 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @607:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || isBinarySearchTree[T](subParts._1, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @607:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 259 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @611:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || !isBinarySearchTree[T](subParts._1, ord) || treeSmallerEqThanValue[T](subParts._1, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @611:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 260 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @622:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || !isBinarySearchTree[T](subParts._1, ord) || !treeSmallerEqThanValue[T](subParts._1, p, ord) || (((((isBinarySearchTree[T](t._3, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](t._3, a, ord)) && isBinarySearchTree[T](_2_right, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @622:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 261 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @642:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || !isBinarySearchTree[T](subParts._1, ord) || !treeSmallerEqThanValue[T](subParts._1, p, ord) || !((((((isBinarySearchTree[T](t._3, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](t._3, a, ord)) && isBinarySearchTree[T](_2_right, ord)) || {
[[35m Debug  [0m]       val t: Boolean = (((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](_2_right, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](t._1).contains(b)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)
[[35m Debug  [0m]       val t: Boolean = ((compare[T](ord, a, b) >= 0 && {
[[35m Debug  [0m]         val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](b, a, t._3, ord)
[[35m Debug  [0m]         treeGreaterEqThanValue[T](t._3, b, ord)
[[35m Debug  [0m]       }) && treeGreaterEqThanValue[T](_2_right, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, _2_right), ord)
[[35m Debug  [0m]       t
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @642:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 262 / 268
[[35m Debug  [0m]  - Now solving 'body assertion' VC for partitionGreaterGreater @653:14...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || !isBinarySearchTree[T](subParts._1, ord) || !treeSmallerEqThanValue[T](subParts._1, p, ord) || !((((((isBinarySearchTree[T](t._3, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](t._3, a, ord)) && isBinarySearchTree[T](_2_right, ord)) || {
[[35m Debug  [0m]       val t: Boolean = (((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](_2_right, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](t._1).contains(b)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)
[[35m Debug  [0m]       val t: Boolean = ((compare[T](ord, a, b) >= 0 && {
[[35m Debug  [0m]         val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](b, a, t._3, ord)
[[35m Debug  [0m]         treeGreaterEqThanValue[T](t._3, b, ord)
[[35m Debug  [0m]       }) && treeGreaterEqThanValue[T](_2_right, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, _2_right), ord)
[[35m Debug  [0m]       !t || ((treeGreaterEqThanValue[T](pr, p, ord) && compare[T](ord, b, p) >= 0) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, b, _2_right, ord)
[[35m Debug  [0m]         treeGreaterEqThanValue[T](_2_right, p, ord)
[[35m Debug  [0m]       }) && treeGreaterEqThanValue[T](Node[T](pr, b, _2_right), p, ord)
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for partitionGreaterGreater @653:14:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 263 / 268
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionGreaterGreater @551:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionGreaterGreater @551:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 264 / 268
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionGreaterGreater @552:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || (tree match {
[[35m Debug  [0m]   case Node(al, a, ar) =>
[[35m Debug  [0m]     (al, a, ar)
[[35m Debug  [0m] })._1.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionGreaterGreater @552:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 265 / 268
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for partitionGreaterGreater @562:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val ar: Tree[T] = t._3
[[35m Debug  [0m]   val t: Boolean = compare[T](ord, t._2, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, t._2, ar, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](ar, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   true
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for partitionGreaterGreater @562:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 266 / 268
[[35m Debug  [0m]  - Now solving 'body assertion: Inner refinement lifting' VC for partitionGreaterGreater @563:11...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: Boolean = compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   true
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Inner refinement lifting' VC for partitionGreaterGreater @563:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 267 / 268
[[35m Debug  [0m]  - Now solving 'postcondition' VC for partitionGreaterGreater @653:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isTreeEmpty[T](tree) || compare[T](ord, treeRootValue[T](tree), p) <= 0 || isTreeEmpty[T](leftSubTree[T](tree)) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) <= 0 || !isValidPartition[T](p, leftSubTree[T](leftSubTree[T](tree)), ord, subParts) || compare[T](ord, treeRootValue[T](leftSubTree[T](tree)), p) < 0 || {
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = tree match {
[[35m Debug  [0m]     case Node(al, a, ar) =>
[[35m Debug  [0m]       (al, a, ar)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val a: T = t._2
[[35m Debug  [0m]   val t: (Tree[T], T, Tree[T]) = t._1 match {
[[35m Debug  [0m]     case Node(bl, b, br) =>
[[35m Debug  [0m]       (bl, b, br)
[[35m Debug  [0m]   }
[[35m Debug  [0m]   val b: T = t._2
[[35m Debug  [0m]   !(compare[T](ord, a, p) >= 0 && {
[[35m Debug  [0m]     val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, a, t._3, ord)
[[35m Debug  [0m]     treeGreaterEqThanValue[T](t._3, p, ord)
[[35m Debug  [0m]   }) || {
[[35m Debug  [0m]     val t: (Tree[T], Tree[T]) = (subParts._1, subParts._2)
[[35m Debug  [0m]     val pr: Tree[T] = subParts._2
[[35m Debug  [0m]     val _2_right: Tree[T] = Node[T](t._3, a, t._3)
[[35m Debug  [0m]     !(((((((((treeSet[T](t._1) == treeSet[T](subParts._1) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](_2_right)) && treeSet[T](_2_right) == treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](subParts._1) ++ treeSet[T](pr) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](subParts._1) ++ treeSet[T](pr)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) == treeSet[T](t._1) ++ Set(b) ++ treeSet[T](t._3)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](t._1) ++ treeSet[T](t._3) ++ Set(a)) && treeSet[T](t._1) ++ treeSet[T](Node[T](pr, b, _2_right)) == treeSet[T](tree)) || !(((((((((treeSize[T](t._1) == treeSize[T](subParts._1) && treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](pr) + BigInt("1")) + treeSize[T](_2_right)) && treeSize[T](_2_right) == (treeSize[T](t._3) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](pr) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == ((((treeSize[T](subParts._1) + treeSize[T](pr)) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == treeSize[T](subParts._1) + treeSize[T](pr)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (((treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) == (treeSize[T](t._1) + BigInt("1")) + treeSize[T](t._3)) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == (treeSize[T](t._1) + treeSize[T](t._3)) + BigInt("1")) && treeSize[T](t._1) + treeSize[T](Node[T](pr, b, _2_right)) == treeSize[T](tree)) || !isBinarySearchTree[T](subParts._1, ord) || !treeSmallerEqThanValue[T](subParts._1, p, ord) || !((((((isBinarySearchTree[T](t._3, ord) && isBinarySearchTree[T](t._3, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)) && treeSet[T](t._3).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeSmallerEqThanValue[T](t._3, a, ord)) && isBinarySearchTree[T](_2_right, ord)) || {
[[35m Debug  [0m]       val t: Boolean = (((((((isBinarySearchTree[T](pr, ord) && isBinarySearchTree[T](_2_right, ord)) && treeSet[T](pr).subsetOf(treeSet[T](t._1))) && treeSmallerEqThanValue[T](t._1, b, ord)) && treeSmallerEqThanValue[T](pr, b, ord)) && treeGreaterEqThanValue[T](t._3, b, ord)) && treeSet[T](t._1).contains(b)) && treeSmallerEqThanValue[T](t._1, a, ord)) && treeGreaterEqThanValue[T](t._3, a, ord)
[[35m Debug  [0m]       val t: Boolean = ((compare[T](ord, a, b) >= 0 && {
[[35m Debug  [0m]         val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](b, a, t._3, ord)
[[35m Debug  [0m]         treeGreaterEqThanValue[T](t._3, b, ord)
[[35m Debug  [0m]       }) && treeGreaterEqThanValue[T](_2_right, b, ord)) && isBinarySearchTree[T](Node[T](pr, b, _2_right), ord)
[[35m Debug  [0m]       !t || !(((treeGreaterEqThanValue[T](pr, p, ord) && compare[T](ord, b, p) >= 0) && {
[[35m Debug  [0m]         val tmp: Unit = subtreeSmallerOrderingTransitivityLemma[T](p, b, _2_right, ord)
[[35m Debug  [0m]         treeGreaterEqThanValue[T](_2_right, p, ord)
[[35m Debug  [0m]       }) && treeGreaterEqThanValue[T](Node[T](pr, b, _2_right), p, ord)) || isValidPartition[T](p, tree, ord, (t._1, Node[T](pr, b, _2_right)))
[[35m Debug  [0m]     }
[[35m Debug  [0m]   }
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for partitionGreaterGreater @653:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 268 / 268
[[35m Debug  [0m] Generating VCs for functions: delMin$0, delMin$18
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 268 / 269
[[35m Debug  [0m]  - Now solving 'precond. (call delMin[T](({   assert(thiss.isInstanc...)' VC for delMin @16:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call delMin[T](({   assert(thiss.isInstanc...)' VC for delMin @16:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 269 / 269
[[35m Debug  [0m] Generating VCs for functions: delMin$0, delMin$18, delMin$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 269 / 279
[[35m Debug  [0m]  - Now solving 'precond. (call delMin[T](({   assert(thiss.isInstanc...)' VC for delMin @16:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call delMin[T](({   assert(thiss.isInstanc...)' VC for delMin @16:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 270 / 279
[[35m Debug  [0m]  - Now solving 'precond. (call delMin[T](({   assert(thiss.isInstanc...)' VC for delMin @16:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call delMin[T](({   assert(thiss.isInstanc...)' VC for delMin @16:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 271 / 279
[[35m Debug  [0m]  - Now solving 'precond. (call getMinTreeEl[T](scrut, {   assert(thi...)' VC for delMin @46:29...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.tree.isInstanceOf[Leaf] || isBinarySearchTree[T](thiss.tree, thiss.ord) && !isTreeEmpty[T](thiss.tree)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call getMinTreeEl[T](scrut, {   assert(thi...)' VC for delMin @46:29:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 272 / 279
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for delMin @44:46...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for delMin @44:46:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 273 / 279
[[35m Debug  [0m]  - Now solving 'class invariant' VC for delMin @45:20...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || !thiss.tree.isInstanceOf[Leaf] || inv[T](SplayHeap[T](Leaf[T](), thiss.ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'class invariant' VC for delMin @45:20:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 274 / 279
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for delMin @45:38...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || !thiss.tree.isInstanceOf[Leaf] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for delMin @45:38:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 275 / 279
[[35m Debug  [0m]  - Now solving 'class invariant' VC for delMin @46:19...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.tree.isInstanceOf[Leaf] || inv[T](SplayHeap[T](getMinTreeEl[T](thiss.tree, thiss.ord)._1, thiss.ord))
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'class invariant' VC for delMin @46:19:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 276 / 279
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for delMin @46:49...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.tree.isInstanceOf[Leaf] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for delMin @46:49:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 277 / 279
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for delMin @46:58...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.tree.isInstanceOf[Leaf] || {
[[35m Debug  [0m]   val tree: Tree[T] = getMinTreeEl[T](thiss.tree, thiss.ord)._1
[[35m Debug  [0m]   thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for delMin @46:58:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 278 / 279
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for delMin @44:46...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for delMin @44:46:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 279 / 279
[[35m Debug  [0m] Generating VCs for functions: setForall$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 279 / 279
[[35m Debug  [0m] Generating VCs for functions: inv$7, inv$9
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 279 / 282
[[35m Debug  [0m]  - Now solving 'precond. (call inv[T](({   assert(thiss.isInstanceOf...)' VC for inv @38:11...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call inv[T](({   assert(thiss.isInstanceOf...)' VC for inv @38:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 280 / 282
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for inv @38:30...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for inv @38:30:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 281 / 282
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for inv @38:36...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for inv @38:36:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 282 / 282
[[35m Debug  [0m] Generating VCs for functions: strictGreaterToNonStrictLemma$0, strictGreaterToNonStrictLemma$2, strictGreaterToNonStrictLemma$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 282 / 286
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictGreaterToNonStrictLemma @80:3...
[[35m Debug  [0m] compare[T](thiss, x, y) <= 0 || compare[T](thiss, x, y) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictGreaterToNonStrictLemma @80:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 283 / 286
[[35m Debug  [0m]  - Now solving 'precond. (call strictGreaterToNonStrictLemma[T](({  ...)' VC for strictGreaterToNonStrictLemma @80:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictGreaterToNonStrictLemma[T](({  ...)' VC for strictGreaterToNonStrictLemma @80:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 284 / 286
[[35m Debug  [0m]  - Now solving 'precond. (call strictGreaterToNonStrictLemma[T](({  ... (require 2)' VC for strictGreaterToNonStrictLemma @80:3...
[[35m Debug  [0m] compare[T](thiss, x, y) <= 0 || compare[T](thiss, x, y) > 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call strictGreaterToNonStrictLemma[T](({  ... (require 2)' VC for strictGreaterToNonStrictLemma @80:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 285 / 286
[[35m Debug  [0m]  - Now solving 'postcondition' VC for strictGreaterToNonStrictLemma @80:3...
[[35m Debug  [0m] compare[T](thiss, x, y) <= 0 || {
[[35m Debug  [0m]   val x$6: Unit = strictGreaterToNonStrictLemma[T](thiss, x, y)
[[35m Debug  [0m]   compare[T](thiss, x, y) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for strictGreaterToNonStrictLemma @80:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 286 / 286
[[35m Debug  [0m] Generating VCs for functions: isMinTreeEl$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 286 / 286
[[35m Debug  [0m] Generating VCs for functions: equalityTransitivityLemma$0, equalityTransitivityLemma$1, equalityTransitivityLemma$4
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 286 / 291
[[35m Debug  [0m]  - Now solving 'precond. (call equalityTransitivityLemma[T](({   ass...)' VC for equalityTransitivityLemma @40:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call equalityTransitivityLemma[T](({   ass...)' VC for equalityTransitivityLemma @40:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 287 / 291
[[35m Debug  [0m]  - Now solving 'precond. (call equalityTransitivityLemma[T](({   ass... (require 2)' VC for equalityTransitivityLemma @40:3...
[[35m Debug  [0m] compare[T](thiss, x, y) != 0 || compare[T](thiss, y, z) != 0 || compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call equalityTransitivityLemma[T](({   ass... (require 2)' VC for equalityTransitivityLemma @40:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 288 / 291
[[35m Debug  [0m]  - Now solving 'postcondition' VC for equalityTransitivityLemma @40:3...
[[35m Debug  [0m] compare[T](thiss, x, y) != 0 || compare[T](thiss, y, z) != 0 || {
[[35m Debug  [0m]   val x$1: Unit = equalityTransitivityLemma[T](thiss, x, y, z)
[[35m Debug  [0m]   compare[T](thiss, x, z) == 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for equalityTransitivityLemma @40:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 289 / 291
[[35m Debug  [0m]  - Now solving 'body assertion' VC for equalityTransitivityLemma @42:12...
[[35m Debug  [0m] compare[T](thiss, x, y) != 0 || compare[T](thiss, y, z) != 0 || consistent[T](thiss, x, y, z)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for equalityTransitivityLemma @42:12:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 290 / 291
[[35m Debug  [0m]  - Now solving 'postcondition' VC for equalityTransitivityLemma @40:3...
[[35m Debug  [0m] compare[T](thiss, x, y) != 0 || compare[T](thiss, y, z) != 0 || !consistent[T](thiss, x, y, z) || compare[T](thiss, x, z) == 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for equalityTransitivityLemma @40:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 291 / 291
[[35m Debug  [0m] Generating VCs for functions: set$5, set$76, set$6
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 291 / 294
[[35m Debug  [0m]  - Now solving 'precond. (call set[T](({   assert(thiss.isInstanceOf...)' VC for set @33:3...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call set[T](({   assert(thiss.isInstanceOf...)' VC for set @33:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 292 / 294
[[35m Debug  [0m]  - Now solving 'precond. (call set[T](({   assert(thiss.isInstanceOf...)' VC for set @33:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call set[T](({   assert(thiss.isInstanceOf...)' VC for set @33:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 293 / 294
[[35m Debug  [0m]  - Now solving 'cast correctness' VC for set @56:38...
[[35m Debug  [0m] !thiss.isInstanceOf[SplayHeap] || thiss.isInstanceOf[SplayHeap]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'cast correctness' VC for set @56:38:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 294 / 294
[[35m Debug  [0m] Generating VCs for functions: nonStrictTransitivityLemma$0, nonStrictTransitivityLemma$1, nonStrictTransitivityLemma$2
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 294 / 304
[[35m Debug  [0m]  - Now solving 'precond. (call nonStrictTransitivityLemma[T](({   as...)' VC for nonStrictTransitivityLemma @94:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call nonStrictTransitivityLemma[T](({   as...)' VC for nonStrictTransitivityLemma @94:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 295 / 304
[[35m Debug  [0m]  - Now solving 'precond. (call nonStrictTransitivityLemma[T](({   as... (require 2)' VC for nonStrictTransitivityLemma @94:3...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || compare[T](thiss, x, y) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call nonStrictTransitivityLemma[T](({   as... (require 2)' VC for nonStrictTransitivityLemma @94:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 296 / 304
[[35m Debug  [0m]  - Now solving 'precond. (call nonStrictTransitivityLemma[T](({   as... (require 3)' VC for nonStrictTransitivityLemma @94:3...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || compare[T](thiss, y, z) >= 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call nonStrictTransitivityLemma[T](({   as... (require 3)' VC for nonStrictTransitivityLemma @94:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 297 / 304
[[35m Debug  [0m]  - Now solving 'postcondition' VC for nonStrictTransitivityLemma @94:3...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || {
[[35m Debug  [0m]   val x$8: Unit = nonStrictTransitivityLemma[T](thiss, x, y, z)
[[35m Debug  [0m]   compare[T](thiss, x, z) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for nonStrictTransitivityLemma @94:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 298 / 304
[[35m Debug  [0m]  - Now solving 'precond. (call equalityTransitivityLemma[T](thiss, x...)' VC for nonStrictTransitivityLemma @99:7...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || !(compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0) || compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call equalityTransitivityLemma[T](thiss, x...)' VC for nonStrictTransitivityLemma @99:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 299 / 304
[[35m Debug  [0m]  - Now solving 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @100:7...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || !(compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0) || {
[[35m Debug  [0m]   val tmp: Unit = equalityTransitivityLemma[T](thiss, x, y, z)
[[35m Debug  [0m]   ((compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs 
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @100:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 300 / 304
[[35m Debug  [0m]  - Now solving 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @103:7...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0 || !(compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) > 0) || ((consistent[T](thiss, x, y, z) && compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs 
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @103:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 301 / 304
[[35m Debug  [0m]  - Now solving 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @109:7...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0 || compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) > 0 || !(compare[T](thiss, x, y) > 0 && compare[T](thiss, y, z) == 0) || ((((inverse[T](thiss, x, y) && consistent[T](thiss, y, z, x)) && inverse[T](thiss, z, x)) && compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs 
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @109:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 302 / 304
[[35m Debug  [0m]  - Now solving 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @117:7...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0 || compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) > 0 || compare[T](thiss, x, y) > 0 && compare[T](thiss, y, z) == 0 || ((transitive[T](thiss, x, y, z) && compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs 
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion: Inlined precondition of check' VC for nonStrictTransitivityLemma @117:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 303 / 304
[[35m Debug  [0m]  - Now solving 'postcondition' VC for nonStrictTransitivityLemma @98:5...
[[35m Debug  [0m] compare[T](thiss, x, y) < 0 || compare[T](thiss, y, z) < 0 || {
[[35m Debug  [0m]   val t: Unit = if (compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) == 0) {
[[35m Debug  [0m]     val tmp: Unit = equalityTransitivityLemma[T](thiss, x, y, z)
[[35m Debug  [0m]     assume(((compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs )
[[35m Debug  [0m]     ()
[[35m Debug  [0m]   } else if (compare[T](thiss, x, y) == 0 && compare[T](thiss, y, z) > 0) {
[[35m Debug  [0m]     assume(((consistent[T](thiss, x, y, z) && compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs )
[[35m Debug  [0m]     ()
[[35m Debug  [0m]   } else if (compare[T](thiss, x, y) > 0 && compare[T](thiss, y, z) == 0) {
[[35m Debug  [0m]     assume(((((inverse[T](thiss, x, y) && consistent[T](thiss, y, z, x)) && inverse[T](thiss, z, x)) && compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs )
[[35m Debug  [0m]     ()
[[35m Debug  [0m]   } else {
[[35m Debug  [0m]     assume(((transitive[T](thiss, x, y, z) && compare[T](thiss, x, z) >= 0)): @ghost  @DropVCs )
[[35m Debug  [0m]     ()
[[35m Debug  [0m]   }
[[35m Debug  [0m]   compare[T](thiss, x, z) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for nonStrictTransitivityLemma @98:5:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 304 / 304
[[35m Debug  [0m] Generating VCs for functions: $init$1, $init$3, $init$4
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 304 / 305
[[35m Debug  [0m]  - Now solving 'precond. (call $init[T](({   assert(thiss.isInstance...)' VC for $init @5:25...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call $init[T](({   assert(thiss.isInstance...)' VC for $init @5:25:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 305 / 305
[[35m Debug  [0m] Generating VCs for functions: treeRootValue$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 305 / 306
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for treeRootValue @53:9...
[[35m Debug  [0m] isTreeEmpty[T](tree) || tree.isInstanceOf[Node]
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for treeRootValue @53:9:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 306 / 306
[[35m Debug  [0m] Generating VCs for functions: compare$0, compare$70
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 306 / 307
[[35m Debug  [0m]  - Now solving 'precond. (call compare[T](({   assert(thiss.isInstan...)' VC for compare @22:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call compare[T](({   assert(thiss.isInstan...)' VC for compare @22:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 307 / 307
[[35m Debug  [0m] Generating VCs for functions: min$3, min$5
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 307 / 308
[[35m Debug  [0m]  - Now solving 'precond. (call min[T](({   assert(thiss.isInstanceOf...)' VC for min @21:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call min[T](({   assert(thiss.isInstanceOf...)' VC for min @21:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 308 / 308
[[35m Debug  [0m] Generating VCs for functions: treeGreaterEqThanValue$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 308 / 308
[[35m Debug  [0m] Generating VCs for functions: subtreeGreaterOrderingTransitivityLemma$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 308 / 312
[[35m Debug  [0m]  - Now solving 'precond. (call nonStrictTransitivityLemma[T](ord, gr...)' VC for subtreeGreaterOrderingTransitivityLemma @101:11...
[[35m Debug  [0m] compare[T](ord, greaterValue, nodeValue) < 0 || !treeSmallerEqThanValue[T](leftTree, nodeValue, ord) || {
[[35m Debug  [0m]   val set: Set[T] = treeSet[T](leftTree)
[[35m Debug  [0m]   compare[T](ord, nodeValue, el) < 0 || compare[T](ord, greaterValue, nodeValue) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call nonStrictTransitivityLemma[T](ord, gr...)' VC for subtreeGreaterOrderingTransitivityLemma @101:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 309 / 312
[[35m Debug  [0m]  - Now solving 'precond. (call nonStrictTransitivityLemma[T](ord, gr... (require 2)' VC for subtreeGreaterOrderingTransitivityLemma @101:11...
[[35m Debug  [0m] compare[T](ord, greaterValue, nodeValue) < 0 || !treeSmallerEqThanValue[T](leftTree, nodeValue, ord) || {
[[35m Debug  [0m]   val set: Set[T] = treeSet[T](leftTree)
[[35m Debug  [0m]   compare[T](ord, nodeValue, el) < 0 || compare[T](ord, greaterValue, nodeValue) < 0 || compare[T](ord, nodeValue, el) >= 0
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call nonStrictTransitivityLemma[T](ord, gr... (require 2)' VC for subtreeGreaterOrderingTransitivityLemma @101:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 310 / 312
[[35m Debug  [0m]  - Now solving 'body assertion' VC for subtreeGreaterOrderingTransitivityLemma @98:7...
[[35m Debug  [0m] compare[T](ord, greaterValue, nodeValue) < 0 || !treeSmallerEqThanValue[T](leftTree, nodeValue, ord) || compare[T](ord, greaterValue, nodeValue) >= 0 && setForall[T](treeSet[T](leftTree), (el: T) => compare[T](ord, nodeValue, el) >= 0 && {
[[35m Debug  [0m]   val tmp: Unit = nonStrictTransitivityLemma[T](ord, greaterValue, nodeValue, el)
[[35m Debug  [0m]   compare[T](ord, greaterValue, el) >= 0
[[35m Debug  [0m] })
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for subtreeGreaterOrderingTransitivityLemma @98:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 311 / 312
[[35m Debug  [0m]  - Now solving 'postcondition' VC for subtreeGreaterOrderingTransitivityLemma @97:5...
[[35m Debug  [0m] compare[T](ord, greaterValue, nodeValue) < 0 || !treeSmallerEqThanValue[T](leftTree, nodeValue, ord) || !(compare[T](ord, greaterValue, nodeValue) >= 0 && setForall[T](treeSet[T](leftTree), (el: T) => compare[T](ord, nodeValue, el) >= 0 && {
[[35m Debug  [0m]   val tmp: Unit = nonStrictTransitivityLemma[T](ord, greaterValue, nodeValue, el)
[[35m Debug  [0m]   compare[T](ord, greaterValue, el) >= 0
[[35m Debug  [0m] })) || treeSmallerEqThanValue[T](leftTree, greaterValue, ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for subtreeGreaterOrderingTransitivityLemma @97:5:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 312 / 312
[[35m Debug  [0m] Generating VCs for functions: binarySearchTreeSplayInsertion$0
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 312 / 315
[[35m Debug  [0m]  - Now solving 'precond. (call partition[T](element, tree, ord))' VC for binarySearchTreeSplayInsertion @820:20...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || isBinarySearchTree[T](tree, ord)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call partition[T](element, tree, ord))' VC for binarySearchTreeSplayInsertion @820:20:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 313 / 315
[[35m Debug  [0m]  - Now solving 'match exhaustiveness' VC for binarySearchTreeSplayInsertion @820:11...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'match exhaustiveness' VC for binarySearchTreeSplayInsertion @820:11:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 314 / 315
[[35m Debug  [0m]  - Now solving 'postcondition' VC for binarySearchTreeSplayInsertion @821:7...
[[35m Debug  [0m] !isBinarySearchTree[T](tree, ord) || {
[[35m Debug  [0m]   val x$28: (Tree[T], Tree[T]) = (partition[T](element, tree, ord)._1, partition[T](element, tree, ord)._2)
[[35m Debug  [0m]   val r: Tree[T] = partition[T](element, tree, ord)._2
[[35m Debug  [0m]   val res: Tree[T] = Node[T](partition[T](element, tree, ord)._1, element, r)
[[35m Debug  [0m]   assume({
[[35m Debug  [0m]     val e: Tree[T] = Node[T](partition[T](element, tree, ord)._1, element, r)
[[35m Debug  [0m]     true
[[35m Debug  [0m]   })
[[35m Debug  [0m]   isBinarySearchTree[T](res, ord) && treeSet[T](res) == treeSet[T](tree) ++ Set(element) && treeSize[T](res) == treeSize[T](tree) + BigInt("1")
[[35m Debug  [0m] }
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for binarySearchTreeSplayInsertion @821:7:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 315 / 315
[[35m Debug  [0m] Generating VCs for functions: selfEqualityLemma$0, selfEqualityLemma$7, selfEqualityLemma$1
[[35m Debug  [0m] Finished generating VCs
[[34m  Info  [0m] Verified: 315 / 319
[[35m Debug  [0m]  - Now solving 'body assertion' VC for selfEqualityLemma @128:12...
[[35m Debug  [0m] inverse[T](thiss, x, x)
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'body assertion' VC for selfEqualityLemma @128:12:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 316 / 319
[[35m Debug  [0m]  - Now solving 'postcondition' VC for selfEqualityLemma @127:3...
[[35m Debug  [0m] !inverse[T](thiss, x, x) || compare[T](thiss, x, x) == 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for selfEqualityLemma @127:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 317 / 319
[[35m Debug  [0m]  - Now solving 'precond. (call selfEqualityLemma[T](({   assert(this...)' VC for selfEqualityLemma @127:3...
[[35m Debug  [0m] true
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'precond. (call selfEqualityLemma[T](({   assert(this...)' VC for selfEqualityLemma @127:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 318 / 319
[[35m Debug  [0m]  - Now solving 'postcondition' VC for selfEqualityLemma @127:3...
[[35m Debug  [0m] val x$9: Unit = selfEqualityLemma[T](thiss, x)
[[35m Debug  [0m] compare[T](thiss, x, x) == 0
[[35m Debug  [0m] Solving with: U:smt-z3
[[35m Debug  [0m]  - Result for 'postcondition' VC for selfEqualityLemma @127:3:
[[35m Debug  [0m]  => VALID
[[34m  Info  [0m] Verified: 319 / 319
[[34m  Info  [0m]   ┌───────────────────┐
[[34m  Info  [0m] ╔═╡ [32mstainless summary[0m ╞════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
[[34m  Info  [0m] ║ └───────────────────┘                                                                                                                                                ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:5:25: [0m   [32m$init[0m                                    [32mprecond. (call $init[T](({   assert(thiss.isInstance...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:820:11: [0m          [32mbinarySearchTreeSplayInsertion[0m           [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:820:20: [0m          [32mbinarySearchTreeSplayInsertion[0m           [32mprecond. (call partition[T](element, tree, ord))[0m                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:821:7: [0m           [32mbinarySearchTreeSplayInsertion[0m           [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.8[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:22:3: [0m         [32mcompare[0m                                  [32mprecond. (call compare[T](({   assert(thiss.isInstan...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:33:3: [0m         [32mconsistent[0m                               [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:33:3: [0m         [32mconsistent[0m                               [32mprecond. (call consistent[T](({   assert(thiss.isIns...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:12:3: [0m        [32mcreateEmpty[0m                              [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:13:5: [0m        [32mcreateEmpty[0m                              [32mclass invariant[0m                                                      [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:14:15: [0m       [32mcreateEmpty[0m                              [32mprecond. (call isEmpty[T](x$1))[0m                                      [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:19:3: [0m        [32mcreateFromList[0m                           [32mnon-negative measure[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:21:7: [0m        [32mcreateFromList[0m                           [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:22:23: [0m       [32mcreateFromList[0m                           [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:24:25: [0m       [32mcreateFromList[0m                           [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:25:11: [0m       [32mcreateFromList[0m                           [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:25:18: [0m       [32mcreateFromList[0m                           [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:16:3: [0m   [32mdelMin[0m                                   [32mprecond. (call delMin[T](({   assert(thiss.isInstanc...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:16:3: [0m   [32mdelMin[0m                                   [32mprecond. (call delMin[T](({   assert(thiss.isInstanc...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:44:46: [0m       [32mdelMin[0m                                   [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:44:46: [0m       [32mdelMin[0m                                   [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:45:20: [0m       [32mdelMin[0m                                   [32mclass invariant[0m                                                      [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:45:38: [0m       [32mdelMin[0m                                   [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:46:19: [0m       [32mdelMin[0m                                   [32mclass invariant[0m                                                      [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:46:29: [0m       [32mdelMin[0m                                   [32mprecond. (call getMinTreeEl[T](scrut, {   assert(thi...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:46:49: [0m       [32mdelMin[0m                                   [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:46:58: [0m       [32mdelMin[0m                                   [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:40:3: [0m         [32mequalityTransitivityLemma[0m                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:40:3: [0m         [32mequalityTransitivityLemma[0m                [32mprecond. (call equalityTransitivityLemma[T](({   ass... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:40:3: [0m         [32mequalityTransitivityLemma[0m                [32mprecond. (call equalityTransitivityLemma[T](({   ass...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:40:3: [0m         [32mequalityTransitivityLemma[0m                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:42:12: [0m        [32mequalityTransitivityLemma[0m                [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:802:3: [0m           [32mgetMinTreeEl[0m                             [32mnon-negative measure[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:806:22: [0m          [32mgetMinTreeEl[0m                             [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:806:43: [0m          [32mgetMinTreeEl[0m                             [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:806:43: [0m          [32mgetMinTreeEl[0m                             [32mprecond. (call getMinTreeElTrivialCase[T](tree, ord))[0m                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:807:43: [0m          [32mgetMinTreeEl[0m                             [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:807:43: [0m          [32mgetMinTreeEl[0m                             [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:807:43: [0m          [32mgetMinTreeEl[0m                             [32mprecond. (call getMinTreeElRecursiveStep[T](tree, ord))[0m              [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:735:3: [0m           [32mgetMinTreeElRecursiveStep[0m                [32mnon-negative measure[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:740:22: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:743:11: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:744:28: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:744:28: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mprecond. (call getMinTreeEl[T](l, ord))[0m                              [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:747:11: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mbody assertion: Inner refinement lifting[0m                             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:755:13: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:761:14: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m1.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:772:14: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:780:14: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.3[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:788:14: [0m          [32mgetMinTreeElRecursiveStep[0m                [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:792:7: [0m           [32mgetMinTreeElRecursiveStep[0m                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:712:21: [0m          [32mgetMinTreeElTrivialCase[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:715:11: [0m          [32mgetMinTreeElTrivialCase[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:717:9: [0m           [32mgetMinTreeElTrivialCase[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:726:7: [0m           [32mgetMinTreeElTrivialCase[0m                  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.7[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:10:3: [0m   [32minsert[0m                                   [32mprecond. (call insert[T](({   assert(thiss.isInstanc...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:10:3: [0m   [32minsert[0m                                   [32mprecond. (call insert[T](({   assert(thiss.isInstanc...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:10:3: [0m   [32minsert[0m                                   [32mprecond. (call insert[T](({   assert(thiss.isInstanc...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:41:5: [0m        [32minsert[0m                                   [32mclass invariant[0m                                                      [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:41:15: [0m       [32minsert[0m                                   [32mprecond. (call binarySearchTreeSplayInsertion[T]({  ...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:41:46: [0m       [32minsert[0m                                   [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:41:61: [0m       [32minsert[0m                                   [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:41:67: [0m       [32minsert[0m                                   [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:43:3: [0m   [32minsertLaw[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:43:3: [0m   [32minsertLaw[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.7[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:43:3: [0m   [32minsertLaw[0m                                [32mprecond. (call insertLaw[T](({   assert(thiss.isInst...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:43:3: [0m   [32minsertLaw[0m                                [32mprecond. (call insertLaw[T](({   assert(thiss.isInst...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:43:3: [0m   [32minsertLaw[0m                                [32mlaw[0m                                                                  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.7[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:38:30: [0m       [32minv[0m                                      [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:38:36: [0m       [32minv[0m                                      [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:38:11: [0m       [32minv[0m                                      [32mprecond. (call inv[T](({   assert(thiss.isInstanceOf...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:25:3: [0m         [32minverse[0m                                  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:25:3: [0m         [32minverse[0m                                  [32mprecond. (call inverse[T](({   assert(thiss.isInstan...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:26:30: [0m        [32minverse[0m                                  [32mbody assertion: Negation overflow[0m                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:76:3: [0m            [32misBinarySearchTree[0m                       [32mnon-negative measure[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:77:17: [0m           [32misBinarySearchTree[0m                       [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:79:31: [0m           [32misBinarySearchTree[0m                       [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:79:56: [0m           [32misBinarySearchTree[0m                       [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:25:3: [0m   [32misEmpty[0m                                  [32mprecond. (call isEmpty[T](({   assert(thiss.isInstan...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:25:3: [0m   [32misEmpty[0m                                  [32mprecond. (call isEmpty[T](({   assert(thiss.isInstan...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:25:3: [0m   [32misEmpty[0m                                  [32mprecond. (call isEmpty[T](({   assert(thiss.isInstan...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:54:47: [0m       [32misEmpty[0m                                  [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:22:49: [0m           [32misTreeEmpty[0m                              [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:23:20: [0m           [32misTreeEmpty[0m                              [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:24:15: [0m           [32misTreeEmpty[0m                              [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:43:9: [0m            [32mleftSubTree[0m                              [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Math.scala:29:5: [0m             [32mlogLemmaInPowerForm[0m                      [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:21:3: [0m   [32mmin[0m                                      [32mprecond. (call min[T](({   assert(thiss.isInstanceOf...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:21:3: [0m   [32mmin[0m                                      [32mprecond. (call min[T](({   assert(thiss.isInstanceOf...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:21:3: [0m   [32mmin[0m                                      [32mprecond. (call min[T](({   assert(thiss.isInstanceOf...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:49:33: [0m       [32mmin[0m                                      [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:49:33: [0m       [32mmin[0m                                      [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:51:27: [0m       [32mmin[0m                                      [32mprecond. (call getMinTreeEl[T](scrut, {   assert(thi...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:51:47: [0m       [32mmin[0m                                      [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:53:3: [0m   [32mminLaw[0m                                   [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:53:3: [0m   [32mminLaw[0m                                   [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:53:3: [0m   [32mminLaw[0m                                   [32mprecond. (call minLaw[T](({   assert(thiss.isInstanc...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:53:3: [0m   [32mminLaw[0m                                   [32mprecond. (call minLaw[T](({   assert(thiss.isInstanc...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:55:62: [0m  [32mminLaw[0m                                   [32mprecond. (call get[T](min[T](thiss)))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:56:52: [0m  [32mminLaw[0m                                   [32mprecond. (call get[T](min[T](thiss)))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:53:3: [0m   [32mminLaw[0m                                   [32mlaw[0m                                                                  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:64:3: [0m         [32mmonotonicInverseLemmaGreater[0m             [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:64:3: [0m         [32mmonotonicInverseLemmaGreater[0m             [32mprecond. (call monotonicInverseLemmaGreater[T](({   ... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:64:3: [0m         [32mmonotonicInverseLemmaGreater[0m             [32mprecond. (call monotonicInverseLemmaGreater[T](({   ...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:64:3: [0m         [32mmonotonicInverseLemmaGreater[0m             [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:66:12: [0m        [32mmonotonicInverseLemmaGreater[0m             [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:72:3: [0m         [32mmonotonicInverseLemmaSmaller[0m             [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:72:3: [0m         [32mmonotonicInverseLemmaSmaller[0m             [32mprecond. (call monotonicInverseLemmaSmaller[T](({   ... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:72:3: [0m         [32mmonotonicInverseLemmaSmaller[0m             [32mprecond. (call monotonicInverseLemmaSmaller[T](({   ...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:72:3: [0m         [32mmonotonicInverseLemmaSmaller[0m             [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:74:12: [0m        [32mmonotonicInverseLemmaSmaller[0m             [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:94:3: [0m         [32mnonStrictTransitivityLemma[0m               [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:94:3: [0m         [32mnonStrictTransitivityLemma[0m               [32mprecond. (call nonStrictTransitivityLemma[T](({   as... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:94:3: [0m         [32mnonStrictTransitivityLemma[0m               [32mprecond. (call nonStrictTransitivityLemma[T](({   as... (require 3)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:94:3: [0m         [32mnonStrictTransitivityLemma[0m               [32mprecond. (call nonStrictTransitivityLemma[T](({   as...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:98:5: [0m         [32mnonStrictTransitivityLemma[0m               [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:99:7: [0m         [32mnonStrictTransitivityLemma[0m               [32mprecond. (call equalityTransitivityLemma[T](thiss, x...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:100:7: [0m        [32mnonStrictTransitivityLemma[0m               [32mbody assertion: Inlined precondition of check[0m                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:103:7: [0m        [32mnonStrictTransitivityLemma[0m               [32mbody assertion: Inlined precondition of check[0m                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:109:7: [0m        [32mnonStrictTransitivityLemma[0m               [32mbody assertion: Inlined precondition of check[0m                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:117:7: [0m        [32mnonStrictTransitivityLemma[0m               [32mbody assertion: Inlined precondition of check[0m                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:37:3: [0m   [32mordering[0m                                 [32mprecond. (call ordering[T](({   assert(thiss.isInsta...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:37:3: [0m   [32mordering[0m                                 [32mprecond. (call ordering[T](({   assert(thiss.isInsta...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:57:40: [0m       [32mordering[0m                                 [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:670:7: [0m           [32mpartition[0m                                [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:671:24: [0m          [32mpartition[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:671:24: [0m          [32mpartition[0m                                [32mprecond. (call partitionEmpty[T](p, tree, ord))[0m                      [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:673:26: [0m          [32mpartition[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:673:26: [0m          [32mpartition[0m                                [32mprecond. (call partitionSmallerEmpty[T](p, tree, ord))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:675:28: [0m          [32mpartition[0m                                [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:675:28: [0m          [32mpartition[0m                                [32mprecond. (call partition[T](p, (scrut.right): @DropV...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:676:13: [0m          [32mpartition[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:676:13: [0m          [32mpartition[0m                                [32mprecond. (call partitionSmallerSmaller[T](p, tree, s...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.3[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:679:28: [0m          [32mpartition[0m                                [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:679:28: [0m          [32mpartition[0m                                [32mprecond. (call partition[T](p, (scrut.left): @DropVC...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:680:13: [0m          [32mpartition[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:680:13: [0m          [32mpartition[0m                                [32mprecond. (call partitionSmallerGreater[T](p, tree, s...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.3[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:684:26: [0m          [32mpartition[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:684:26: [0m          [32mpartition[0m                                [32mprecond. (call partitionGreaterEmpty[T](p, tree, ord))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:686:28: [0m          [32mpartition[0m                                [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:686:28: [0m          [32mpartition[0m                                [32mprecond. (call partition[T](p, (scrut.right): @DropV...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:687:13: [0m          [32mpartition[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:687:13: [0m          [32mpartition[0m                                [32mprecond. (call partitionGreaterSmaller[T](p, tree, s...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.3[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:690:28: [0m          [32mpartition[0m                                [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:690:28: [0m          [32mpartition[0m                                [32mprecond. (call partition[T](p, (scrut.left): @DropVC...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:691:13: [0m          [32mpartition[0m                                [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:691:13: [0m          [32mpartition[0m                                [32mprecond. (call partitionGreaterGreater[T](p, tree, s...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.3[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:695:38: [0m          [32mpartition[0m                                [32mnon-negative measure[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:146:3: [0m           [32mpartitionEmpty[0m                           [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:408:21: [0m          [32mpartitionGreaterEmpty[0m                    [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:409:21: [0m          [32mpartitionGreaterEmpty[0m                    [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:411:11: [0m          [32mpartitionGreaterEmpty[0m                    [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:412:7: [0m           [32mpartitionGreaterEmpty[0m                    [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.6[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:413:9: [0m           [32mpartitionGreaterEmpty[0m                    [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:415:11: [0m          [32mpartitionGreaterEmpty[0m                    [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:541:21: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:542:22: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:543:21: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call treeRootValue[T](leftSubTree[T](tree)))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:543:35: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:544:29: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call leftSubTree[T](leftSubTree[T](tree)))[0m                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:544:41: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:548:9: [0m           [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:548:21: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call treeRootValue[T](leftSubTree[T](tree)))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:548:35: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:551:11: [0m          [32mpartitionGreaterGreater[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:552:11: [0m          [32mpartitionGreaterGreater[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:555:9: [0m           [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:557:11: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:562:11: [0m          [32mpartitionGreaterGreater[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:563:11: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion: Inner refinement lifting[0m                             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:585:14: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:603:14: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:607:14: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:611:14: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:622:14: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.7[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:636:11: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:642:14: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m1.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:648:11: [0m          [32mpartitionGreaterGreater[0m                  [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:653:7: [0m           [32mpartitionGreaterGreater[0m                  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:653:14: [0m          [32mpartitionGreaterGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.6[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:427:21: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:428:22: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:429:21: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call treeRootValue[T](leftSubTree[T](tree)))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:429:35: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:430:29: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call rightSubTree[T](leftSubTree[T](tree)))[0m                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:430:42: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:434:9: [0m           [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:434:21: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call treeRootValue[T](leftSubTree[T](tree)))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:434:35: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:435:24: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call treeRootValue[T](leftSubTree[T](tree)))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:435:38: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call leftSubTree[T](tree))[0m                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:438:11: [0m          [32mpartitionGreaterSmaller[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:439:11: [0m          [32mpartitionGreaterSmaller[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:442:9: [0m           [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:444:11: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:449:11: [0m          [32mpartitionGreaterSmaller[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:469:14: [0m          [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:485:14: [0m          [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:496:14: [0m          [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.7[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:501:11: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call subtreeGreaterOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:507:14: [0m          [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.3[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:520:14: [0m          [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:525:11: [0m          [32mpartitionGreaterSmaller[0m                  [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:531:7: [0m           [32mpartitionGreaterSmaller[0m                  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:531:14: [0m          [32mpartitionGreaterSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:156:21: [0m          [32mpartitionSmallerEmpty[0m                    [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:157:21: [0m          [32mpartitionSmallerEmpty[0m                    [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:159:11: [0m          [32mpartitionSmallerEmpty[0m                    [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:160:7: [0m           [32mpartitionSmallerEmpty[0m                    [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.7[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:161:9: [0m           [32mpartitionSmallerEmpty[0m                    [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:164:11: [0m          [32mpartitionSmallerEmpty[0m                    [32mprecond. (call subtreeGreaterOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:294:21: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:295:22: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:296:21: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call treeRootValue[T](rightSubTree[T](tree)))[0m              [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:296:35: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:297:29: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call leftSubTree[T](rightSubTree[T](tree)))[0m                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:297:41: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:301:9: [0m           [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:301:21: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call treeRootValue[T](rightSubTree[T](tree)))[0m              [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:301:35: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:302:21: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:303:24: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:306:11: [0m          [32mpartitionSmallerGreater[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:308:9: [0m           [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:311:11: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call subtreeGreaterOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:315:11: [0m          [32mpartitionSmallerGreater[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:316:11: [0m          [32mpartitionSmallerGreater[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:337:14: [0m          [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:353:14: [0m          [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:366:14: [0m          [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:371:11: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call subtreeGreaterOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:377:14: [0m          [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:388:14: [0m          [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.9[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:393:11: [0m          [32mpartitionSmallerGreater[0m                  [32mprecond. (call subtreeSmallerOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:399:7: [0m           [32mpartitionSmallerGreater[0m                  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.4[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:399:14: [0m          [32mpartitionSmallerGreater[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:176:21: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:177:22: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:178:21: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call treeRootValue[T](rightSubTree[T](tree)))[0m              [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:178:35: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:179:29: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call rightSubTree[T](rightSubTree[T](tree)))[0m               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:179:42: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:183:9: [0m           [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:183:21: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:184:24: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call treeRootValue[T](tree))[0m                               [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:185:21: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call treeRootValue[T](rightSubTree[T](tree)))[0m              [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:185:35: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:186:24: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call treeRootValue[T](rightSubTree[T](tree)))[0m              [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:186:38: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call rightSubTree[T](tree))[0m                                [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:188:11: [0m          [32mpartitionSmallerSmaller[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:190:9: [0m           [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:193:11: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call subtreeGreaterOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:197:11: [0m          [32mpartitionSmallerSmaller[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:198:11: [0m          [32mpartitionSmallerSmaller[0m                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:204:11: [0m          [32mpartitionSmallerSmaller[0m                  [32mbody assertion: Inner refinement lifting[0m                             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:224:14: [0m          [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:240:14: [0m          [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:246:14: [0m          [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:256:14: [0m          [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.8[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:262:11: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call subtreeGreaterOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.2[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:272:14: [0m          [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m1.8[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:279:11: [0m          [32mpartitionSmallerSmaller[0m                  [32mprecond. (call subtreeGreaterOrderingTransitivityLem...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:284:7: [0m           [32mpartitionSmallerSmaller[0m                  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.6[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:284:14: [0m          [32mpartitionSmallerSmaller[0m                  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.5[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:33:9: [0m            [32mrightSubTree[0m                             [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:127:3: [0m        [32mselfEqualityLemma[0m                        [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:127:3: [0m        [32mselfEqualityLemma[0m                        [32mprecond. (call selfEqualityLemma[T](({   assert(this...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:127:3: [0m        [32mselfEqualityLemma[0m                        [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:128:12: [0m       [32mselfEqualityLemma[0m                        [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:33:3: [0m   [32mset[0m                                      [32mprecond. (call set[T](({   assert(thiss.isInstanceOf...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:33:3: [0m   [32mset[0m                                      [32mprecond. (call set[T](({   assert(thiss.isInstanceOf...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:56:38: [0m       [32mset[0m                                      [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Math.scala:15:3: [0m             [32msignumLemma1[0m                             [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Math.scala:17:33: [0m            [32msignumLemma1[0m                             [32mbody assertion: Negation overflow[0m                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Math.scala:17:41: [0m            [32msignumLemma1[0m                             [32mbody assertion: Negation overflow[0m                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:29:3: [0m   [32msize[0m                                     [32mprecond. (call size[T](({   assert(thiss.isInstanceO...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/FunctionalHeap.scala:29:3: [0m   [32msize[0m                                     [32mprecond. (call size[T](({   assert(thiss.isInstanceO...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/SplayHeap.scala:55:40: [0m       [32msize[0m                                     [32mcast correctness[0m                                                     [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:80:3: [0m         [32mstrictGreaterToNonStrictLemma[0m            [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:80:3: [0m         [32mstrictGreaterToNonStrictLemma[0m            [32mprecond. (call strictGreaterToNonStrictLemma[T](({  ... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:80:3: [0m         [32mstrictGreaterToNonStrictLemma[0m            [32mprecond. (call strictGreaterToNonStrictLemma[T](({  ...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:80:3: [0m         [32mstrictGreaterToNonStrictLemma[0m            [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:87:3: [0m         [32mstrictSamllerToNonStrictLemma[0m            [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:87:3: [0m         [32mstrictSamllerToNonStrictLemma[0m            [32mprecond. (call strictSamllerToNonStrictLemma[T](({  ... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:87:3: [0m         [32mstrictSamllerToNonStrictLemma[0m            [32mprecond. (call strictSamllerToNonStrictLemma[T](({  ...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:87:3: [0m         [32mstrictSamllerToNonStrictLemma[0m            [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:48:3: [0m         [32mstrictlyMonotonicInverseLemmaGreater[0m     [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:48:3: [0m         [32mstrictlyMonotonicInverseLemmaGreater[0m     [32mprecond. (call strictlyMonotonicInverseLemmaGreater[... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:48:3: [0m         [32mstrictlyMonotonicInverseLemmaGreater[0m     [32mprecond. (call strictlyMonotonicInverseLemmaGreater[...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:48:3: [0m         [32mstrictlyMonotonicInverseLemmaGreater[0m     [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:50:12: [0m        [32mstrictlyMonotonicInverseLemmaGreater[0m     [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:56:3: [0m         [32mstrictlyMonotonicInverseLemmaSmaller[0m     [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:56:3: [0m         [32mstrictlyMonotonicInverseLemmaSmaller[0m     [32mprecond. (call strictlyMonotonicInverseLemmaSmaller[... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:56:3: [0m         [32mstrictlyMonotonicInverseLemmaSmaller[0m     [32mprecond. (call strictlyMonotonicInverseLemmaSmaller[...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:56:3: [0m         [32mstrictlyMonotonicInverseLemmaSmaller[0m     [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:58:12: [0m        [32mstrictlyMonotonicInverseLemmaSmaller[0m     [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:97:5: [0m            [32msubtreeGreaterOrderingTransitivityLemma[0m  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:98:7: [0m            [32msubtreeGreaterOrderingTransitivityLemma[0m  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:101:11: [0m          [32msubtreeGreaterOrderingTransitivityLemma[0m  [32mprecond. (call nonStrictTransitivityLemma[T](ord, gr... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:101:11: [0m          [32msubtreeGreaterOrderingTransitivityLemma[0m  [32mprecond. (call nonStrictTransitivityLemma[T](ord, gr...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:121:5: [0m           [32msubtreeSmallerOrderingTransitivityLemma[0m  [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:122:7: [0m           [32msubtreeSmallerOrderingTransitivityLemma[0m  [32mbody assertion[0m                                                       [32mvalid[0m  [32mU:smt-z3[0m  [32m0.1[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:125:11: [0m          [32msubtreeSmallerOrderingTransitivityLemma[0m  [32mprecond. (call nonStrictTransitivityLemma[T](ord, el... (require 2)[0m  [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:125:11: [0m          [32msubtreeSmallerOrderingTransitivityLemma[0m  [32mprecond. (call nonStrictTransitivityLemma[T](ord, el...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:29:3: [0m         [32mtransitive[0m                               [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Ordering.scala:29:3: [0m         [32mtransitive[0m                               [32mprecond. (call transitive[T](({   assert(thiss.isIns...)[0m             [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:53:9: [0m            [32mtreeRootValue[0m                            [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:60:3: [0m            [32mtreeSet[0m                                  [32mnon-negative measure[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:60:43: [0m           [32mtreeSet[0m                                  [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:62:37: [0m           [32mtreeSet[0m                                  [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:62:51: [0m           [32mtreeSet[0m                                  [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:14:3: [0m            [32mtreeSize[0m                                 [32mnon-negative measure[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:14:45: [0m           [32mtreeSize[0m                                 [32mmatch exhaustiveness[0m                                                 [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:15:20: [0m           [32mtreeSize[0m                                 [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:16:27: [0m           [32mtreeSize[0m                                 [32mpostcondition[0m                                                        [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:16:39: [0m           [32mtreeSize[0m                                 [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ║ [32msrc/Trees.scala:16:53: [0m           [32mtreeSize[0m                                 [32mmeasure decreases[0m                                                    [32mvalid[0m  [32mU:smt-z3[0m  [32m0.0[0m ║
[[34m  Info  [0m] ╟┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄╢
[[34m  Info  [0m] ║ [32mtotal: 316  valid: 316  (0 from cache) invalid: 0    unknown: 0    time:    37.8[0m                                                                                     ║
[[34m  Info  [0m] ╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
[[34m  Info  [0m] Shutting down executor service.
